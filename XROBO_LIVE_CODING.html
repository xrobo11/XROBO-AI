<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<title>XROBO BLE</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="https://unpkg.com/blockly/blockly.min.js">// 안전 바인딩: 기존 바인딩이 없을 때만 연결
(function(){
  const sb = document.getElementById('saveBtn');
  if (sb && !sb.dataset.boundSave){
    sb.addEventListener('click', saveProject);
    sb.dataset.boundSave = '1';
  }
  const lb = document.getElementById('loadBtn');
  if (lb && !lb.dataset.boundLoad){
    lb.addEventListener('click', loadProject);
    lb.dataset.boundLoad = '1';
  }
})();

</script>
<style>
  :root{
    --pad:10px;
    --uiScale: 1;
    --headerH: 64px;
    --btnH: 36px;
    --gap: 8px;
    --headerBgTop: #fff7ed;
    --headerBgBottom: #fffbeb;
    --headerBorder: #fed7aa;
    --logH: 180px;
    --blue: #1d4ed8;

    /* 핸들/삼각형 */
    --handleWBase: 22;
    --handleHBase: 28;
    --triWBase:   14;
    --triHBase:   12;

    /* 계산값 */
    --handleW: calc(var(--handleWBase) * var(--uiScale) * 1px);
    --handleH: calc(var(--handleHBase) * var(--uiScale) * 1px);
    --triW:    calc(var(--triWBase)    * var(--uiScale) * 1px);
    --triH:    calc(var(--triHBase)    * var(--uiScale) * 1px);
    --linkBar: calc(3 * var(--uiScale) * 1px);

    /* 서보 유닛 전체 스케일 */
    --servoScale: 0.7;
  }
  *{ box-sizing:border-box; }
  html, body{ height:100%; }
  body{ margin:0; font-family:system-ui, sans-serif; background:#fff; }

  /* ── 헤더 ───────────────────────────────── */
  header{
    padding: 8px 12px;
    background: linear-gradient(180deg, var(--headerBgTop), var(--headerBgBottom));
    border-bottom: 1px solid var(--headerBorder);
    position:relative; z-index:10;
  }
  #topbar{
    display:flex; align-items:center; gap: calc(var(--gap) * var(--uiScale));
    flex-wrap: wrap;
  }
  .title{
    font-weight: 800; letter-spacing: .2px;
    color:#7c2d12; margin-right: 12px;
    font-size: calc(18px * var(--uiScale));
  }
  .spacer{ flex: 1 1 auto; }

  .btn{
    height: calc(var(--btnH) * var(--uiScale));
    padding: 0 calc(12px * var(--uiScale));
    border:0; border-radius: calc(10px * var(--uiScale));
    display:inline-flex; align-items:center; justify-content:center;
    font-size: calc(14px * var(--uiScale)); font-weight:600;
    box-shadow:0 2px 8px rgba(0,0,0,.08);
    background:#f3f4f6; color:#111827; cursor:pointer;
    user-select:none;
  }
  #connectToggle{ background:#2563eb; color:#fff; }
  #rtToggle.on{ background:#2563eb; color:#fff; }
  #rtToggle:not(.on){ background:#f59e0b; color:#fff; }
  #runToggle{ background:#16a34a; color:#fff; }
  #fsBtn{ background:#111827; color:#fff; }

  .state{
    display:inline-flex; align-items:center; gap:calc(6px * var(--uiScale));
    height: calc(var(--btnH) * var(--uiScale));
    padding: 0 calc(6px * var(--uiScale));
    font-size: calc(12px * var(--uiScale));
  }
  .badgeDot{
    width: calc(22px * var(--uiScale));
    height: calc(22px * var(--uiScale));
    border-radius: 50%;
    display:inline-flex; align-items:center; justify-content:center;
    font-size: calc(11px * var(--uiScale));
    font-weight:800; color:#fff;
    box-shadow: 0 0 0 calc(4px * var(--uiScale)) rgba(0,0,0,.06) inset;
  }
  .badgeDot.on{ background:#3b82f6; }
  .badgeDot.off{ background:#ef4444; }

  /* ── 레이아웃 ─────────────────────────── */
  #main{
    display:flex; width:100%;
    height: calc(100vh - var(--headerH));
    min-height: 0;
  }
  #left{
    position:relative; flex:1 1 auto; min-width:0; height:100%;
    min-height:0;
    display:flex; overflow:visible;
  }
  #blocklyDiv{ flex:1 1 auto; min-width:0; height:100%; width:100%; }

  #right{
    flex:0 0 40%; display:flex; flex-direction:column; background:#fff;
    margin:8px 8px 8px 0; border:1px solid #e5e7eb; border-left:3px solid var(--blue);
    border-radius:12px 0 0 12px; box-shadow:0 2px 10px rgba(0,0,0,.04);
    overflow:hidden; position:relative; min-height:0;
  }
  #rightTop{
    flex:1 1 auto; min-height:0;
    border-bottom:1px solid #e5e7eb; background:#f5f7fa; color:#111827;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    font-size: calc(13px * var(--uiScale)); line-height:1.45;
    padding: calc(12px * var(--uiScale));
    overflow:auto; white-space:pre; tab-size:2;
  }
  #rightBottom{
    flex: 0 0 var(--logH);
    display: flex; flex-direction: column;
    min-height: 0; overflow: hidden;
    padding: calc(10px * var(--uiScale));
    background:#0b0f14; color:#d1e4ff; border-top:1px solid #1f2937;
  }
  #log{
    flex: 1 1 0; min-height: 0; overflow: auto; white-space: pre-wrap;
    background:#0b0f14; border:1px solid #1f2937; border-radius: calc(8px * var(--uiScale));
    padding: calc(10px * var(--uiScale));
    font-family: ui-monospace, Menlo, Consolas, monospace;
    font-size: calc(12px * var(--uiScale)); color:#d1e4ff;
  }

  #panelHandle{
    position:absolute; top: calc(12px * var(--uiScale)); right: 0;
    z-index:9999; width: var(--handleW); height: var(--handleH);
    background: var(--blue); border: 0; border-radius: calc(6px * var(--uiScale));
    box-shadow: 0 2px 8px rgba(0,0,0,.18);
    cursor: pointer; padding: 0;
  }
  #panelHandle::before{
    content:''; position:absolute; top:0; right: calc(0px - var(--linkBar));
    width: var(--linkBar); height:100%; background: var(--blue);
    border-top-right-radius: calc(6px * var(--uiScale));
    border-bottom-right-radius: calc(6px * var(--uiScale));
  }
  #panelHandle::after{
    content:''; position:absolute; top:50%; transform: translateY(-50%);
    width:0; height:0; border-style: solid;
  }
  #panelHandle.open::after{
    left: calc((var(--handleW) - var(--triW)) / 2);
    border-width: var(--triH) 0 var(--triH) var(--triW);
    border-color: transparent transparent transparent white;
  }
  #panelHandle.closed::after{
    left: calc((var(--handleW) - var(--triW)) / 2);
    border-width: var(--triH) var(--triW) var(--triH) 0;
    border-color: transparent white transparent transparent;
  }
  .blocklyZoom,.blocklyTrash{ display:block !important; }

  body.fs-active #main{ height: calc(100vh - var(--headerH)); }
  body.panel-collapsed #right{ display:none; }
  body.panel-collapsed #left{ flex:1 1 100%; }

  /* ───────────── 모달(멀티 서보 설정) ───────────── */
  /* === modal speedbox (delay) select styling: smaller arrow & spacing === */
#servoModal .speedbox { position: relative; }
#servoModal .speedbox select {
  -webkit-appearance: none; appearance: none;
  width: calc(100% - 10px); height: 100%;
  border: 0; outline: none; background: transparent;
  text-align: center; color: #111827; font-size: calc(12px * var(--servoScale));
  padding-right: 18px; /* space for arrow */
}
#servoModal .speedbox::after{
  content: '▾';
  position: absolute;
  right: 6px; top: 50%; transform: translateY(-50%);
  font-size: calc(10px * var(--servoScale));
  color: #6b7280; pointer-events: none;
}

  
  .modal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center;
          background:rgba(0,0,0,.45); z-index:10000; }
  .modal.show{ display:flex; }
  .modal-card{
    width:min(98vw, 1400px);
    height:min(98vh, 1040px);
    background:#fff; border-radius:12px; box-shadow:0 18px 60px rgba(0,0,0,.25);
    display:flex; flex-direction:column; overflow:hidden;
  }
  .modal-head{ display:flex; align-items:center; gap:8px; padding:10px;
    background:#fafafa; border-bottom:1px solid #e5e7eb; }
  .modal-head .title{ font-size:14px; color:#111827; font-weight:800; }
  .modal-head .sp{ flex:1 1 auto; }
  .modal-head .btn{ height:30px; background:#fff; border:1px solid #d1d5db; }
  .modal-body{ position:relative; flex:1 1 auto; }

  .board{ position:absolute; inset:0; overflow:auto; background:#ffffff; }
  .board-stage{
    position:absolute; left:0; top:0;
    width:200%; height:200%;
    background-size:contain; background-repeat:no-repeat; background-position:center;
  }
  .unit{
    position:absolute; width:calc(128px * var(--servoScale)); height:calc(128px * var(--servoScale));
    background:#d1d5db; border:1px solid #9ca3af; border-radius:10px;
    box-shadow:0 2px 8px rgba(0,0,0,.12);
    user-select:none; touch-action:none;
  }
  .unit.dragging{ box-shadow:0 8px 18px rgba(0,0,0,.22); outline:1px dashed #cbd5e1; }
  .handle{
    position:absolute; inset:0 auto auto 0; height:calc(22px * var(--servoScale)); width:100%;
    display:flex; align-items:center; justify-content:center;
    font-size:calc(12px * var(--servoScale)); font-weight:900; letter-spacing:.3px; color:#111827;
    background:#e5e7eb; border-bottom:1px solid #d1d5db; border-radius:10px 10px 0 0;
    cursor:grab; z-index:3;
  }
  .handle:active{ cursor:grabbing; }
  .pwr-top{
    position:absolute; right:calc(4px * var(--servoScale)); top:50%; transform:translateY(-50%);
    width:calc(16px * var(--servoScale)); height:calc(16px * var(--servoScale));
    border-radius:50%; display:grid; place-items:center;
    border:1px solid #d1d5db; color:#fff; font-size:calc(9px * var(--servoScale)); font-weight:900;
    background:#2563eb; cursor:pointer; user-select:none;
  }
  .pwr-top.off{ background:#ef4444; }
  .row{
    position:absolute; top:calc(26px * var(--servoScale)); left:50%; transform:translateX(-50%);
    width:calc(128px * var(--servoScale) - 10px); height:calc(24px * var(--servoScale));
    display:flex; gap:calc(6px * var(--servoScale)); z-index:2;
  }
  .numbox, .speedbox{
    flex:1 1 0; height:100%; border-radius:7px; background:#ffffff; border:1px solid #d1d5db;
    display:flex; align-items:center; justify-content:center;
  }
  .numbox input, .speedbox input, .speedbox select{
    width:calc(100% - 10px); height:100%; border:0; outline:none; background:transparent; color:#111827; text-align:center;
    font-size:calc(12px * var(--servoScale));
  }
  /* number input spinner 제거 (speedbox) */
  .speedbox input::-webkit-outer-spin-button,
  .speedbox input::-webkit-inner-spin-button{ -webkit-appearance:none; margin:0; }
  .speedbox input{ -moz-appearance:textfield; }

  .dial-svg{
    position:absolute; left:50%; top:calc(50% + 20px * var(--servoScale)); transform:translate(-50%,-50%);
    width:calc(56px * var(--servoScale)); height:calc(56px * var(--servoScale));
    z-index:1;
  }
  .ring-base{ fill:#0a0a0a; stroke:#111827; stroke-width:2; }
  .tick{ stroke:#9aa3b2; stroke-width:2; stroke-linecap:round; }
  .dot{ transition: fill .12s ease, filter .12s ease, r .12s ease, stroke .12s ease; }
  .dot.blue{ stroke:#1e3a8a; stroke-width:.6; }
  .dot.red { fill:#ef4444; stroke:#7f1d1d; stroke-width:.6; filter: drop-shadow(0 0 6px rgba(239,68,68,.9)); }

  /* === 추가: 서보 번호 드롭다운 & number 스핀 제거 === */
  .sno-select{
    position:absolute; right:calc(26px * var(--servoScale) + 8px); top:50%; transform:translateY(-50%);
    height:calc(18px * var(--servoScale)); min-width:calc(48px * var(--servoScale));
    background:#ffffff; border:1px solid #d1d5db; border-radius:4px;
    font-size:calc(10px * var(--servoScale)); line-height:1; padding:0 calc(6px * var(--servoScale));
    color:#111827;
  }
  /* number input spinner 제거 */
  input[type=number]::-webkit-outer-spin-button,
  input[type=number]::-webkit-inner-spin-button{ -webkit-appearance:none; margin:0; }
  input[type=number]{ -moz-appearance:textfield; }


  .trash-top{
    position:absolute; left:calc(4px * var(--servoScale)); top:50%; transform:translateY(-50%);
    width:calc(18px * var(--servoScale)); height:calc(18px * var(--servoScale));
    border-radius:4px; display:grid; place-items:center;
    background:#ffffff; border:1px solid #d1d5db; color:#111827;
    font-size:calc(11px * var(--servoScale)); font-weight:900;
    cursor:pointer; user-select:none;
  }
  .trash-top:hover{ background:#ef4444; border-color:#b91c1c; color:#fff; }

  /* === 파일 드롭다운 === */
  .dropdown{ position:relative; }
  .dropdown .menu{
    position:absolute; right:0; top:calc(100% + 4px);
    display:none; min-width:140px;
    background:#ffffff; border:1px solid #d1d5db; border-radius:8px;
    box-shadow:0 6px 16px rgba(0,0,0,.12); padding:6px;
    z-index:1000;
  }
  .dropdown .menu.show{ display:block; }
  .dropdown .menu > button{
    width:100%; background:transparent; border:0; cursor:pointer;
    padding:8px 10px; border-radius:6px;
    font-size:calc(13px * var(--uiScale));
    text-align:left; color:#111827;
  }
  .dropdown .menu > button:hover{ background:#f3f4f6; }

</style>

<!-- injected: file button color + inline dial popover styles -->
<style id="xrobo-inline-dial-style">
  /* 회색 '파일' 드롭다운 버튼 */
  #fileBtn{ background:#6b7280 !important; color:#ffffff !important; }

  /* 인라인 서보 다이얼 팝오버 */
  .xrobo-dial-pop{
    position:absolute; inset:auto auto auto auto;
    width: 180px; height: 164px;
    background:#f9fafb; border:1px solid #d1d5db; border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.18);
    z-index: 2000; padding:10px 10px 12px 10px;
    display:grid; grid-template-rows: 22px 1fr;
  }
  .xrobo-dial-head{
    display:flex; align-items:center; justify-content:space-between;
    font-size:12px; font-weight:700; color:#111827;
  }
  .xrobo-dial-close{ border:0; background:transparent; cursor:pointer; font-size:16px; line-height:1; color:#6b7280; }
  .xrobo-dial-body{ position:relative; }
  .xrobo-dial-row{
    position:absolute; left:50%; top:12px; transform:translateX(-50%);
    width: 150px; height: 26px; display:flex; gap:6px;
  }
  .xrobo-dial-num, .xrobo-dial-speed{
    flex:1 1 0; height:100%;
    background:#ffffff; border:1px solid #d1d5db; border-radius:7px;
    display:flex; align-items:center; justify-content:center;
  }
  .xrobo-dial-num input, .xrobo-dial-speed select{
    width:calc(100% - 8px); height:100%; border:0; outline:none; background:transparent; color:#111827; text-align:center;
    font-size:12px;
  }
  /* number input spinner 제거 */
  .xrobo-dial-num input::-webkit-outer-spin-button,
  .xrobo-dial-num input::-webkit-inner-spin-button{ -webkit-appearance:none; margin:0; }
  .xrobo-dial-num input{ -moz-appearance:textfield; }

  .xrobo-dial-svg{
    position:absolute; left:50%; top:84px; transform:translate(-50%,-50%);
    width:72px; height:72px;
  }
  .xrobo-dial-ring{ fill:#0a0a0a; stroke:#111827; stroke-width:2; }
  .xrobo-dial-tick{ stroke:#9aa3b2; stroke-width:2; stroke-linecap:round; }
  .xrobo-dial-dot{ transition: r .12s ease, fill .12s ease, stroke .12s ease; }
  .xrobo-dial-dot.red{ fill:#ef4444; stroke:#7f1d1d; stroke-width:.6; filter: drop-shadow(0 0 6px rgba(239,68,68,.9)); }
  .xrobo-dial-dot.blue{ stroke:#1e3a8a; stroke-width:.6; }

  /* 라이브 ON/OFF 토글 버튼 */
  .xrobo-dial-head-right{ display:flex; align-items:center; gap:6px; }
  .xrobo-live-toggle{
    border:0; border-radius:7px; padding:2px 8px; margin-right:2px; cursor:pointer;
    font-weight:700; font-size:12px; color:#ffffff;
  }
  .xrobo-live-toggle.off{ background:#ef4444; } /* red */
  .xrobo-live-toggle.on{  background:#2563eb; } /* blue */
</style>


<style id="xrobo-vsplit-style">
  /* 오른쪽 패널 상/하 분할바 */
  #rightResizer{
    flex: 0 0 8px;
    background: linear-gradient(180deg,#e5e7eb,#d1d5db);
    cursor: row-resize;
    border-top: 1px solid #cbd5e1;
    border-bottom: 1px solid #cbd5e1;
  }
  body.vs-resizing, body.vs-resizing *{ cursor: row-resize !important; user-select: none !important; }
</style>


<!-- removed xrobo-kp4x4-v9-style -->


<!-- injected: 4x4 keypad v14 (Android-only) -->
<style id="xrobo-kp4x4-v14-style">
  /* 4x4 키패드 (전화패드 스타일 + 외곽 라인) - 전역 70% 축소 */
  :root { --xroboKpScale: .7; }
  #xrobo-kp4x4-v14{
    position:absolute; left:0; top:0; display:none; z-index:2147483647;
    background:#000; border:2px solid #000; border-radius:calc(16px * var(--xroboKpScale));
    padding: calc(12px * var(--xroboKpScale)); box-shadow:0 16px 46px rgba(0,0,0,.45);
    user-select:none; touch-action:manipulation;
  }
  #xrobo-kp4x4-v14.show{ display:block; }
  #xrobo-kp4x4-v14 .display{
    margin-bottom:calc(10px * var(--xroboKpScale)); background:#0b0f14; color:#e5e7eb;
    border:1px solid #1f2937; border-radius:calc(10px * var(--xroboKpScale));
    padding:calc(10px * var(--xroboKpScale)) calc(12px * var(--xroboKpScale));
    font-weight:800; font-size:calc(18px * var(--xroboKpScale)); letter-spacing:.6px; min-height:24px;
  }
  #xrobo-kp4x4-v14 .grid{
    display:grid; grid-template-columns: repeat(4, calc(56px * var(--xroboKpScale)));
    grid-auto-rows: calc(56px * var(--xroboKpScale));
    gap: calc(10px * var(--xroboKpScale));
  }
  #xrobo-kp4x4-v14 button{
    border:0; border-radius:calc(12px * var(--xroboKpScale)); background:#fff; color:#111;
    font-weight:900; font-size:calc(20px * var(--xroboKpScale));
    box-shadow:0 calc(4px * var(--xroboKpScale)) calc(14px * var(--xroboKpScale)) rgba(0,0,0,.22);
    cursor:pointer;
  }
  #xrobo-kp4x4-v14 button:active{ transform:translateY(1px); }
  #xrobo-kp4x4-v14 .op{ background:#e6eefc; color:#0b3aa6; font-weight:800; }
  #xrobo-kp4x4-v14 .back{ background:#111827; color:#fff; font-size:calc(18px * var(--xroboKpScale)); }
  #xrobo-kp4x4-v14 .clear{ background:#e5e7eb; color:#111827; font-size:calc(16px * var(--xroboKpScale)); font-weight:800; }
  #xrobo-kp4x4-v14 .wide{ grid-column: span 2; height:calc(56px * var(--xroboKpScale)); font-size:calc(18px * var(--xroboKpScale)); font-weight:800; }
  #xrobo-kp4x4-v14 .ok{ background:#2563eb; color:#fff; }
  #xrobo-kp4x4-v14 .cancel{ background:#6b7280; color:#fff; }
</style>
<style id="xrobo-dial-select-align">
/* === Dial speed/dropdown visual alignment === */
.xrobo-dial-pop .speedbox select{
  -webkit-appearance: none;
  appearance: none;
  background:#fff;
  border:1px solid #cbd5e1;
  border-radius:8px;
  padding:6px 28px 6px 10px;
  font-size:14px;
  line-height:1.3;
  height:32px;
  box-shadow: 0 1px 2px rgba(0,0,0,.06);
}
.xrobo-dial-pop .speedbox{ position: relative; }
.xrobo-dial-pop .speedbox::after{
  content: '▾';
  position: absolute;
  right: 10px; top: 50%; transform: translateY(-50%);
  pointer-events: none;
  font-size: 12px; color:#4b5563;
}
</style>
</head>
<body>
  <!-- 헤더 -->
  <header id="appHeader">
    <div id="topbar">
      <div class="title">XROBO BLE</div>
      <div class="spacer"></div>

      <!-- 저장/불러오기 버튼 -->
            <!-- 파일 드롭다운 -->
      <div class="dropdown" id="fileDropdown">
        <button id="fileBtn" class="btn" title="파일">파일 ▾</button>
        <div id="fileMenu" class="menu" role="menu" aria-hidden="true">
          <button data-cmd="new" role="menuitem">새로만들기</button>
          <button data-cmd="save" role="menuitem">저장하기</button>
          <button data-cmd="load" role="menuitem">불러오기</button>
        </div>
      </div>
      

      <span class="state"><span id="statusDot" class="badgeDot off">off</span></span>
      <div class="dropdown" id="connectDropdown"><button id="connectToggle" class="btn">연결 ▾</button>
  <div id="connectMenu" class="menu" role="menu" aria-hidden="true">
    <button data-mode="usb" role="menuitem">USB</button>
    <button data-mode="ble" role="menuitem">블루투스</button>
  </div>
</div>
      <button id="runToggle" class="btn" disabled>▶ 실행</button>
      <button id="fsBtn" class="btn" title="전체화면">전체화면</button>
    </div>
  </header>

  <!-- 본문 -->
  <div id="main">
    <div id="left">
      <div id="blocklyDiv"></div>
      <button id="panelHandle" class="open" title="실행창 닫기"></button>
    </div>

    <div id="right">
      <div id="rightTop"></div>
      <div id="rightResizer" class="vsplit" title="크기 조절 바"></div>
      
      <div id="rightBottom">
        <div style="font-size:calc(12px * var(--uiScale));color:#9ca3af;">실행 로그</div>
        <div id="log"></div>
      </div>
    </div>
  </div>

  <!-- 툴박스 -->
  <xml id="toolbox" style="display:none">
    <category name="이벤트" colour="#f59e0b"><block type="xrobo_start"></block></category>

    <category name="입력" colour="#06b6d4">
      <block type="in_xkeypad"><field name="PIN">IN1</field><field name="BTN">B1</field></block>
      <block type="in_ir_dist"><field name="PIN">IN1</field>
        <value name="DIST"><shadow type="math_number"><field name="NUM">10</field></shadow></value></block>
      <block type="in_touch"><field name="PIN">IN1</field></block>
    </category>

    <category name="출력" colour="#60a5fa">
      <block type="motor12_dd"><field name="M1">20</field><field name="M2">20</field><field name="MS">500</field></block>
      <block type="motor12_in">
        <value name="M1"><shadow type="math_number"><field name="NUM">20</field></shadow></value>
        <value name="M2"><shadow type="math_number"><field name="NUM">20</field></shadow></value>
        <value name="MS"><shadow type="math_number"><field name="NUM">500</field></shadow></value>
      </block>

      <block type="motor34_dd"><field name="M3">20</field><field name="M4">20</field><field name="MS">500</field></block>
      <block type="motor34_in">
        <value name="M3"><shadow type="math_number"><field name="NUM">20</field></shadow></value>
        <value name="M4"><shadow type="math_number"><field name="NUM">20</field></shadow></value>
        <value name="MS"><shadow type="math_number"><field name="NUM">500</field></shadow></value>
      </block>      <block type="servo_in"><field name="OUT">OUT1</field>
        <value name="ANG"><shadow type="math_number"><field name="NUM">90</field></shadow></value></block>
      <block type="servo_slow"><field name="OUT">OUT1</field>
        <value name="DELAY"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
        <value name="ANG"><shadow type="math_number"><field name="NUM">90</field></shadow></value></block>

      <block type="melody"><field name="PITCH">C4</field>
        <value name="DUR"><shadow type="math_number"><field name="NUM">200</field></shadow></value>
        <value name="WAIT"><shadow type="math_number"><field name="NUM">250</field></shadow></value></block>

      <!-- LED: UI는 CPU/OUT1..8 + 값 0~20(20은 '숨쉬기'), 전송은 LED <채널번호> <값> -->
      <block type="led_ctrl">
        <field name="TGT">CPU</field>
        <field name="VAL">0</field>
      </block>

      <!-- 멀티 서보 블록 -->
      <block type="multi_servo"></block>
    </category>

    <category name="제어" colour="#10b981">
      <block type="wait_seconds">
        <value name="SEC"><shadow type="math_number"><field name="NUM">1</field></shadow></value>
      </block>
      <block type="repeat_forever"></block>
      <block type="controls_repeat_ext">
        <value name="TIMES"><shadow type="math_number"><field name="NUM">3</field></shadow></value>
      </block>
      <block type="controls_if"></block>
      <block type="controls_if"><mutation else="1"></mutation></block>
    </category>

    <!-- 연산 카테고리 (유지) -->
    <category name="연산" colour="#22c55e">
      <block type="math_number"><field name="NUM">0</field></block>
      <block type="math_arithmetic">
        <field name="OP">ADD</field>
        <value name="A"><shadow type="math_number"><field name="NUM">1</field></shadow></value>
        <value name="B"><shadow type="math_number"><field name="NUM">1</field></shadow></value>
      </block>
      <block type="logic_compare">
        <field name="OP">EQ</field>
        <value name="A"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
        <value name="B"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
      </block>
      <block type="logic_operation"><field name="OP">AND</field></block>
      <block type="logic_negate"></block>
      <block type="logic_boolean"><field name="BOOL">TRUE</field></block>
      <block type="math_random_int">
        <value name="FROM"><shadow type="math_number"><field name="NUM">1</field></shadow></value>
        <value name="TO"><shadow type="math_number"><field name="NUM">10</field></shadow></value>
      </block>
    </category>

    <category name="변수" colour="#f97316" custom="VARIABLE"></category>
    <category name="내블록" colour="#ef4444" custom="PROCEDURE"></category>
  </xml>

  <!-- 멀티 서보 설정 모달 -->
  <div id="servoModal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <div class="modal-head">
        <div id="modalTitle" class="title">멀티 서보 설정</div>
        <div class="sp"></div>
        <button id="rtToggle" class="btn" title="실시간 전송 토글">실시간: OFF</button>
        <button id="addServoBtn" class="btn">+ 서보 추가</button>
        <input id="bgUrl" class="btn" style="width:260px;text-align:left" placeholder="배경 이미지 URL (선택)">
        <button id="applyBg" class="btn">배경 적용</button>
        <button id="closeModal" class="btn">저장 & 닫기 ✕</button>
      </div>
      <div class="modal-body">
        <div id="board" class="board">
          <div id="boardStage" class="board-stage"></div>
        </div>
      </div>
    </div>
  </div>

<script>

// === 변수 블록 한국어 라벨 적용 ===
if (typeof Blockly !== 'undefined' && Blockly.Msg) {
  // 'set %1 to %2' -> '%1 설정하기 %2'
  Blockly.Msg['VARIABLES_SET'] = '%1 설정하기 %2';
  // 'change %1 by %2' -> '%1 %2 만큼 변경하기'
  Blockly.Msg['MATH_CHANGE_TITLE'] = '%1 %2 만큼 변경하기';
  // 기본 변수명 라벨(선택)
  if (!Blockly.Msg['MATH_CHANGE_TITLE_ITEM']) Blockly.Msg['MATH_CHANGE_TITLE_ITEM'] = '변수';
}

/* ================= Blockly 기본 설정 ================= */
class XroboZelosProvider extends Blockly.zelos.ConstantProvider {
  constructor(){ super(); this.ADD_START_HATS = true; }
}
class XroboZelosRenderer extends Blockly.zelos.Renderer {
  constructor(){ super('xrobo_zelos'); }
  makeConstants_(){ return new XroboZelosProvider(); }
}
Blockly.blockRendering.register('xrobo_zelos', XroboZelosRenderer);

const XroboTheme = Blockly.Theme.defineTheme('xrobo_theme', {
  base: Blockly.Themes.Zelos, componentStyles: { startHats: true }
});

const ws = Blockly.inject('blocklyDiv', {
  toolbox: document.getElementById('toolbox'),
  renderer: 'xrobo_zelos', theme: XroboTheme,
  grid: { spacing:20, length:3, colour:'#eee', snap:true },
  zoom: { controls:true, wheel:true }
});

/* ================= 상수/옵션 ================= */
const PINS_IN=[["IN1","IN1"],["IN2","IN2"],["IN3","IN3"],["IN4","IN4"]];
const PINS_OUT=[["OUT1","OUT1"],["OUT2","OUT2"],["OUT3","OUT3"],["OUT4","OUT4"],["OUT5","OUT5"],["OUT6","OUT6"],["OUT7","OUT7"],["OUT8","OUT8"]];
const KEYS_B=[["B1","B1"],["B2","B2"],["B3","B3"],["B4","B4"],["B5","B5"]];
const SPEEDS=Array.from({length:41},(_,i)=>20-i).map(v=>[String(v),String(v)]);
const TIMES100=Array.from({length:10},(_,i)=>(100*(i+1))).map(v=>[String(v),String(v)]);
const ANG_5=Array.from({length:37},(_,i)=>i*5).map(v=>[String(v),String(v)]);

/* LED UI */
const LED_TGT=[["CPU","CPU"],["OUT1","OUT1"],["OUT2","OUT2"],["OUT3","OUT3"],["OUT4","OUT4"],["OUT5","OUT5"],["OUT6","OUT6"],["OUT7","OUT7"],["OUT8","OUT8"]];
const LED_VALS=Array.from({length:21},(_,i)=>[i===20?'숨쉬기':String(i), String(i)]);

const PITCHES=(()=>{const KR=["도","레","미","파","솔","라","시"],EN=["C","D","E","F","G","A","B"],L=[];
  for(let o=4;o<=6;o++) for(let i=0;i<7;i++) L.push([`${KR[i]}${o}`, `${EN[i]}${o}`]); return L;})();

/* ================= 커스텀 블록 정의 ================= */
Blockly.defineBlocksWithJsonArray([
  { "type":"xrobo_start", "message0":"XROBO start", "nextStatement":null, "colour":36, "hat":"cap" },

  { "type":"in_xkeypad", "message0":"X 키패드 핀 %1 버튼 %2",
    "args0":[{"type":"field_dropdown","name":"PIN","options":PINS_IN},{"type":"field_dropdown","name":"BTN","options":KEYS_B}],
    "output":"Boolean","colour":198 },

  { "type":"in_ir_dist", "message0":"적외선센서 핀 %1 거리 %2 이내",
    "args0":[{"type":"field_dropdown","name":"PIN","options":PINS_IN},{"type":"input_value","name":"DIST","check":"Number"}],
    "output":"Boolean","colour":198 },

  { "type":"in_touch", "message0":"접촉센서 핀 %1 눌림",
    "args0":[{"type":"field_dropdown","name":"PIN","options":PINS_IN}],
    "output":"Boolean","colour":198 },

  { "type":"motor12_dd","message0":"모터 M1 %1  M2 %2  시간 %3 ms",
    "args0":[{"type":"field_dropdown","name":"M1","options":SPEEDS},{"type":"field_dropdown","name":"M2","options":SPEEDS},{"type":"field_dropdown","name":"MS","options":TIMES100}],
    "previousStatement":null,"nextStatement":null,"inputsInline":true,"colour":210 },

  { "type":"motor12_in","message0":"모터 M1 %1  M2 %2  시간 %3 ms",
    "args0":[{"type":"input_value","name":"M1","check":"Number"},{"type":"input_value","name":"M2","check":"Number"},{"type":"input_value","name":"MS","check":"Number"}],
    "previousStatement":null,"nextStatement":null,"inputsInline":true,"colour":210 },

  { "type":"motor34_dd","message0":"모터 M3 %1  M4 %2  시간 %3 ms",
    "args0":[{"type":"field_dropdown","name":"M3","options":SPEEDS},{"type":"field_dropdown","name":"M4","options":SPEEDS},{"type":"field_dropdown","name":"MS","options":TIMES100}],
    "previousStatement":null,"nextStatement":null,"inputsInline":true,"colour":210 },

  { "type":"motor34_in","message0":"모터 M3 %1  M4 %2  시간 %3 ms",
    "args0":[{"type":"input_value","name":"M3","check":"Number"},{"type":"input_value","name":"M4","check":"Number"},{"type":"input_value","name":"MS","check":"Number"}],
    "previousStatement":null,"nextStatement":null,"inputsInline":true,"colour":210 },

  { "type":"servo_dd","message0":"서보모터 %1 각도 %2°",
    "args0":[{"type":"field_dropdown","name":"OUT","options":PINS_OUT},{"type":"field_dropdown","name":"ANG","options":ANG_5}],
    "previousStatement":null,"nextStatement":null,"inputsInline":true,"colour":30 },

  { "type":"servo_in","message0":"서보모터 %1 각도 %2°",
    "args0":[{"type":"field_dropdown","name":"OUT","options":PINS_OUT},{"type":"input_value","name":"ANG","check":"Number"}],
    "previousStatement":null,"nextStatement":null,"inputsInline":true,"colour":30 },

  { "type":"servo_slow","message0":"슬로우 서보 %1 지연 %2 ms 각도 %3°",
    "args0":[{"type":"field_dropdown","name":"OUT","options":PINS_OUT},{"type":"input_value","name":"DELAY","check":"Number"},{"type":"input_value","name":"ANG","check":"Number"}],
    "previousStatement":null,"nextStatement":null,"inputsInline":true,"colour":30 },

  { "type":"melody","message0":"멜로디 음높이 %1 소리시간 %2 ms 대기시간 %3 ms",
    "args0":[{"type":"field_dropdown","name":"PITCH","options":PITCHES},{"type":"input_value","name":"DUR","check":"Number"},{"type":"input_value","name":"WAIT","check":"Number"}],
    "previousStatement":null,"nextStatement":null,"inputsInline":true,"colour":300 },

  { "type":"led_ctrl","message0":"LED %1 값 %2",
    "args0":[{"type":"field_dropdown","name":"TGT","options":LED_TGT},{"type":"field_dropdown","name":"VAL","options":LED_VALS}],
    "previousStatement":null,"nextStatement":null,"inputsInline":true,"colour":330 },

  /* 멀티 서보 (설정/복사 아이콘) */
  {
    "type":"multi_servo",
    "message0":"멀티 서보 (개수: %1)  %2 %3",
    "args0":[
      { "type":"field_label_serializable", "name":"COUNT", "text":"0" },
      { "type":"field_image", "name":"CFG", "src":"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='24' viewBox='0 0 64 24'><rect x='0' y='0' width='64' height='24' rx='6' ry='6' fill='%238b5e34'/><text x='32' y='16' text-anchor='middle' font-size='12' font-weight='700' fill='%23ffffff'>설정</text></svg>", "width":83, "height": 31, "alt":"설정" },
      { "type":"field_image", "name":"DUP", "src":"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='24' viewBox='0 0 64 24'><rect x='0' y='0' width='64' height='24' rx='6' ry='6' fill='%238b5e34'/><text x='32' y='16' text-anchor='middle' font-size='12' font-weight='700' fill='%23ffffff'>복사</text></svg>", "width":83, "height": 31, "alt":"복사" }
    ],
    "previousStatement":null, "nextStatement":null, "colour": 30,
    "extensions": ["multi_servo_cfg"]
  },

  /* 제어(커스텀) */
  { "type":"wait_seconds","message0":"%1 초 기다리기","args0":[{"type":"input_value","name":"SEC","check":"Number"}],
    "previousStatement":null,"nextStatement":null,"colour":160 },
  { "type":"repeat_forever","message0":"계속 반복하기 %1 %2",
    "args0":[{"type":"input_dummy"},{"type":"input_statement","name":"DO"}],
    "previousStatement":null,"nextStatement":null,"colour":160 }
]);

/* 멀티 서보 확장(설정/복사) */
const multiServoConfigs = new Map(); // blockId -> { bgUrl, units:[...] }

function cloneConfigDeep(cfg){
  return JSON.parse(JSON.stringify(cfg || { bgUrl:'', units:[] }));
}
function duplicateMultiServoBlock(srcBlock){
  const cfgOld = multiServoConfigs.get(srcBlock.id);
  const cfgNew = cloneConfigDeep(cfgOld || {
    bgUrl:'',
    units:[{name:'S1', angle:90, speed:0, power:true, x:12, y:56}]
  });
  const pos = srcBlock.getRelativeToSurfaceXY();
  const newBlock = ws.newBlock('multi_servo');
  newBlock.initSvg(); newBlock.render();
  newBlock.moveBy(pos.x + 30, pos.y + 30);
  multiServoConfigs.set(newBlock.id, cfgNew);
  newBlock.setFieldValue(String(cfgNew.units?.length || 0), 'COUNT');
  newBlock.select();
}
Blockly.Extensions.register('multi_servo_cfg', function (){
  const cfgBtn = this.getField('CFG');
  const dupBtn = this.getField('DUP');
  if (cfgBtn?.setOnClickHandler) cfgBtn.setOnClickHandler(() => openServoModal(this));
  if (dupBtn?.setOnClickHandler) dupBtn.setOnClickHandler(() => duplicateMultiServoBlock(this));
  this.setOnChange(function(){
    if (this.isDeadOrDying_) multiServoConfigs.delete(this.id);
  });
});

/* ================= 식/코드 생성 유틸 ================= */
/* ===== 변수 처리 보조(최소 추가) ===== */
function cIdent(name){
  let s = String(name||'var');
  s = (s.normalize ? s.normalize('NFKD') : s).replace(/[^A-Za-z0-9_]/g,'_');
  if(/^[0-9]/.test(s)) s = 'v_' + s;
  if(!s) s = 'v_var';
  return s;
}
function getVarNameFromField(b){
  try{
    const fld = b && b.getField && b.getField('VAR');
    if(fld && typeof fld.getText === 'function'){
      const t = fld.getText();
      if(t) return t;
    }
    const id = (b && typeof b.getFieldValue === 'function') ? b.getFieldValue('VAR') : null;
    const ws_ = b && b.workspace;
    if(ws_ && typeof ws_.getVariableById === 'function' && id){
      const v = ws_.getVariableById(id);
      if(v && v.name) return v.name;
    }
  }catch(_){}
  return 'var';
}
function getAllVarNames(){
  try{
    if(ws && typeof ws.getAllVariables === 'function'){
      return ws.getAllVariables().map(v=>v.name);
    }
  }catch(_){}
  return [];
}

/* 숫자 입력: 하위 블록 AST를 평가해 값으로 변환 */
function numFromInput(parent, name, def=0){
  try{
    const child = parent?.getInputTargetBlock?.(name);
    if(!child) return def;
    const ast = condFromBlock(child);
    const v = numEval(ast);
    return Number.isFinite(v) ? v : def;
  }catch(_){ return def; }
}

/* 코드 생성용 표현식(Arduino C 표시를 위한 텍스트) */
function exprFromBlock(b){
  if(!b) return '/* cond */';
  switch(b.type){
    case 'variables_get': {
      const name = getVarNameFromField(b);
      return cIdent(name);
    }

    case 'math_number': return String(b.getFieldValue('NUM'));
    case 'logic_boolean': return (b.getFieldValue('BOOL')==='TRUE')?'true':'false';
    case 'logic_negate': return '!(' + exprFromBlock(b.getInputTargetBlock('BOOL')) + ')';
    case 'logic_operation': {
      const op = b.getFieldValue('OP')==='AND'?'&&':'||';
      return '('+exprFromBlock(b.getInputTargetBlock('A'))+' '+op+' '+exprFromBlock(b.getInputTargetBlock('B'))+')';
    }
    case 'logic_compare': {
      const map={EQ:'==',NEQ:'!=',LT:'<',LTE:'<=',GT:'>',GTE:'>='};
      const op = map[b.getFieldValue('OP')] || '==';
      return '('+exprFromBlock(b.getInputTargetBlock('A'))+' '+op+' '+exprFromBlock(b.getInputTargetBlock('B'))+')';
    }
    case 'math_arithmetic': {
      const map={ADD:'+',MINUS:'-',MULTIPLY:'*',DIVIDE:'/',POWER:'^'};
      const op = map[b.getFieldValue('OP')]||'+';
      const A = exprFromBlock(b.getInputTargetBlock('A'));
      const B = exprFromBlock(b.getInputTargetBlock('B'));
      return '('+A+' '+op+' '+B+')';
    }
    case 'math_random_int': {
      const A = exprFromBlock(b.getInputTargetBlock('FROM')) || '0';
      const B = exprFromBlock(b.getInputTargetBlock('TO')) || '0';
      return `random(${A}, ${B})`
    }
    /* 센서 표현(미리보기용) */
    case 'in_touch':  return `TOUCH(${b.getFieldValue('PIN')})`;
    case 'in_xkeypad':return `XKEY(${b.getFieldValue('PIN')}, ${b.getFieldValue('BTN')})`;
    case 'in_ir_dist':{
      const d = numFromInput(b,'DIST',10);
      return `(IR(${b.getFieldValue('PIN')}) <= ${Math.round(d)})`;
    }
  }
  return '/* cond */';
}

/* ================= 입력 블록 → 아두이노 연동(RET 파서 등) ================= */
let rxLineBuf = '';
const retWaiters = []; // queue of resolvers
function onBleLine(line){
  try{
    const m = String(line||'').match(/^\s*RET\s+([01])\s*$/);
    if(m){
      const v = (m[1] === '1');
      const fn = retWaiters.shift();
      if (typeof fn === 'function') fn(v);
    }
  }catch(_){}
}
function onBleChunk(text){
  rxLineBuf += String(text||'').replace(/\r/g,'');
  let idx;
  while((idx = rxLineBuf.indexOf('\n')) !== -1){
    const line = rxLineBuf.slice(0, idx);
    rxLineBuf = rxLineBuf.slice(idx + 1);
    onBleLine(line);
  }
}
async function sendAndWaitRET(cmd, timeout=1500){
  if(!writeChar) throw new Error('BLE 미연결');
  let resolved = false;
  const p = new Promise((resolve, reject)=>{
    const wrapper = (v)=>{ resolved=true; resolve(v); };
    retWaiters.push(wrapper);
    setTimeout(()=>{
      if(!resolved){
        const i = retWaiters.indexOf(wrapper);
        if(i>=0) retWaiters.splice(i,1);
        reject(new Error('RET 시간초과'));
      }
    }, timeout);
  });
  await writeChar.writeValue(enc(cmd + '\n'));
  log('➡️ ' + cmd);
  return await p;
}

/* ================= AST 생성/평가기 ================= */
function condFromBlock(b){
  if(!b) return {type:'lit', v:false};
  switch(b.type){
    case 'variables_get': {
      const name = getVarNameFromField(b);
      return {type:'var', n: name};
    }

    case 'logic_boolean':
      return {type:'lit', v: (b.getFieldValue('BOOL')==='TRUE')};
    case 'logic_negate':
      return {type:'not', a: condFromBlock(b.getInputTargetBlock('BOOL')) };
    case 'logic_operation': {
      const isAnd = b.getFieldValue('OP')==='AND';
      return {type: isAnd ? 'and' : 'or',
              a: condFromBlock(b.getInputTargetBlock('A')),
              b: condFromBlock(b.getInputTargetBlock('B'))};
    }
    /* 입력 3종 */
    case 'in_touch':
      return {type:'SW', pin:b.getFieldValue('PIN')};
    case 'in_ir_dist': {
      const d = numFromInput(b,'DIST',10);
      return {type:'IRS', pin:b.getFieldValue('PIN'), cm: Math.max(1, Math.round(d))};
    }
    case 'in_xkeypad': {
      const raw = String(b.getFieldValue('BTN')||'B1');
      const n = parseInt(raw.replace(/[^0-9]/g,''),10) || 1;
      return {type:'XKEY', pin:b.getFieldValue('PIN'), val:n};
    }
    /* 비교/숫자 연산 */
    case 'logic_compare': {
      const map={EQ:'==',NEQ:'!=',LT:'<',LTE:'<=',GT:'>',GTE:'>='};
      return {type:'cmp', op: map[b.getFieldValue('OP')]||'==',
              a: condFromBlock(b.getInputTargetBlock('A')),
              b: condFromBlock(b.getInputTargetBlock('B'))};
    }
    case 'math_number':
      return {type:'num', v: Number(b.getFieldValue('NUM')||0)};
    case 'math_arithmetic':
      return {type:'arith', op:b.getFieldValue('OP')||'ADD',
              a: condFromBlock(b.getInputTargetBlock('A')),
              b: condFromBlock(b.getInputTargetBlock('B'))};
    case 'math_random_int':
      return {type:'rand',
              a: condFromBlock(b.getInputTargetBlock('FROM')),
              b: condFromBlock(b.getInputTargetBlock('TO'))};
  }
  return {type:'lit', v:false};
}
function numEval(node){
  if(!node) return 0;
  switch(node.type){
    case 'var': {
      const k = node.n;
      const v = (typeof rtVars==='object' && rtVars && Object.prototype.hasOwnProperty.call(rtVars,k)) ? rtVars[k] : 0;
      return Number(v) || 0;
    }

    case 'num': return Number(node.v)||0;
    case 'lit': return node.v ? 1 : 0;
    case 'arith': {
      const A=numEval(node.a), B=numEval(node.b);
      switch(node.op){
        case 'ADD': return A+B;
        case 'MINUS': return A-B;
        case 'MULTIPLY': return A*B;
        case 'DIVIDE': return B? A/B : 0;
        case 'POWER': return Math.pow(A,B);
      }
      return 0;
    }
    case 'rand': {
      const A=Math.floor(numEval(node.a)), B=Math.floor(numEval(node.b));
      const lo = Math.min(A,B), hi = Math.max(A,B);
      return Math.floor(Math.random()*(hi-lo+1))+lo;
    }
    default: return 0;
  }
}
async function boolEval(node){
  if(!node) return false;
  switch(node.type){
    case 'var': return !!numEval(node);

    case 'lit': return !!node.v;
    case 'num': return !!numEval(node);
    case 'not': return !(await boolEval(node.a));
    case 'and': {
      const L=await boolEval(node.a);
      if(!L) return false;
      return await boolEval(node.b);
    }
    case 'or': {
      const L=await boolEval(node.a);
      if(L) return true;
      return await boolEval(node.b);
    }
    case 'cmp': {
      const A=numEval(node.a), B=numEval(node.b);
      switch(node.op){
        case '==': return A==B;
        case '!=': return A!=B;
        case '<':  return A<B;
        case '<=': return A<=B;
        case '>':  return A>B;
        case '>=': return A>=B;
      }
      return false;
    }
    /* BLE 쿼리 */
    case 'SW':   return await sendAndWaitRET(`SW ${node.pin}`);
    case 'IRS':  return await sendAndWaitRET(`IRS ${node.pin} ${node.cm}`);
    case 'XKEY': return await sendAndWaitRET(`XKEY ${node.pin} ${node.val}`);
  }
  return false;
}

/* ================= 순회/코드 생성 ================= */
function outToS(out){
  const m = String(out||'').match(/^OUT(\d)$/);
  return m ? ('S'+m[1]) : String(out||'');
}
const clampAng180 = a => Math.max(0, Math.min(180, Math.round(Number(a)||0)));

function walkNode(b, list){
  if(!b) return;
  switch(b.type){
    /* === 변수 대입/증가 (최소 추가) === */
    case 'variables_set': {
      try{
        const name = getVarNameFromField(b);
        const vb = b.getInputTargetBlock && b.getInputTargetBlock('VALUE');
        const valExpr = exprFromBlock(vb);
        const valAst  = condFromBlock(vb);
        list.push({type:'SETVAR', name:String(name), valExpr, valAst});
      }catch(_){ /* no-op */ }
      break;
    }
    case 'math_change':
    case 'variables_change': {
      try{
        const name = getVarNameFromField(b);
        const db = b.getInputTargetBlock && b.getInputTargetBlock('DELTA');
        const deltaExpr = exprFromBlock(db) || '0';
        const deltaAst  = condFromBlock(db);
        list.push({
          type:'SETVAR',
          name:String(name),
          valExpr:`(${cIdent(name)} + ${deltaExpr})`,
          valAst: { type:'arith', op:'ADD', a:{type:'var', n:name}, b: deltaAst }
        });
      }catch(_){ /* no-op */ }
      break;
    }

    case 'motor12_dd':{
      const v1=+b.getFieldValue('M1'),v2=+b.getFieldValue('M2'),ms=+b.getFieldValue('MS');
      list.push({type:'CMD',s:`M12 ${v1} ${v2} ${ms}`}); if(ms>0) list.push({type:'W',args:[ms]}); break; }
    case 'motor12_in':{
      const v1=numFromInput(b,'M1',0),v2=numFromInput(b,'M2',0),ms=numFromInput(b,'MS',0);
      list.push({type:'CMD',s:`M12 ${Math.round(v1)} ${Math.round(v2)} ${Math.round(ms)}`}); if(ms>0) list.push({type:'W',args:[ms]}); break; }
    case 'motor34_dd':{
      const v3=+b.getFieldValue('M3'),v4=+b.getFieldValue('M4'),ms=+b.getFieldValue('MS');
      list.push({type:'CMD',s:`M34 ${v3} ${v4} ${ms}`}); if(ms>0) list.push({type:'W',args:[ms]}); break; }
    case 'motor34_in':{
      const v3=numFromInput(b,'M3',0),v4=numFromInput(b,'M4',0),ms=numFromInput(b,'MS',0);
      list.push({type:'CMD',s:`M34 ${Math.round(v3)} ${Math.round(v4)} ${Math.round(ms)}`}); if(ms>0) list.push({type:'W',args:[ms]}); break; }

    /* 서보 */
    case 'servo_dd':{
      const out=b.getFieldValue('OUT'),ang=+b.getFieldValue('ANG'); 
      const S=outToS(out), A=clampAng180(ang);
      list.push({type:'CMD',s:`SV ${S} ${A}`}); break; }
    case 'servo_in':{
      const out=b.getFieldValue('OUT'),ang=numFromInput(b,'ANG',90); 
      const S=outToS(out), A=clampAng180(ang);
      list.push({type:'CMD',s:`SV ${S} ${A}`}); break; }
    case 'servo_slow':{
      const out=b.getFieldValue('OUT'),del=numFromInput(b,'DELAY',5),ang=numFromInput(b,'ANG',90);
      const S=outToS(out), D=Math.max(0, Math.min(180, Math.round(del))), A=clampAng180(ang);
      list.push({type:'CMD',s:`SVS ${S} ${D} ${A}`}); break; }

    case 'melody':{
      const p=b.getFieldValue('PITCH'),dur=numFromInput(b,'DUR',200),wait=numFromInput(b,'WAIT',250);
      list.push({type:'CMD',s:`MEL ${p} ${Math.round(dur)} ${Math.round(wait)}`}); if(wait>0) list.push({type:'W',args:[wait]}); break; }

    /* LED */
    case 'led_ctrl':{
      const t=b.getFieldValue('TGT');
      const v=b.getFieldValue('VAL');
      let ch=0;
      if(t==='CPU') ch=0; else{ const m=t.match(/^OUT(\d)$/); ch=m?parseInt(m[1],10):0; }
      list.push({type:'CMD', s:`LED ${ch} ${v}`});
      break;
    }

    /* 멀티 서보 */
    case 'multi_servo':{
      const cfg = multiServoConfigs.get(b.id);
      const units = (cfg?.units||[]).slice();
      const idx = u => { const m=String(u?.name||'').match(/S(\d+)/i); return m?parseInt(m[1],10):9999; };
      units.sort((a,b)=> idx(a)-idx(b));
      for(const u of units){
        const name = u?.name || 'S1';
        const spd  = Math.max(0, Math.min(20, parseInt(u?.speed,10)||0));
        const ang  = clampAng180(u?.angle||90);
        list.push({type:'CMD', s:`SVS ${name} ${spd} ${ang}`});
      }
      break;
    }

    /* 제어 */
    case 'repeat_forever':{
      const inner=[]; const first=b.getInputTargetBlock('DO'); walkChain(first, inner);
      list.push({type:'LOOP_INF',body:inner}); break; }
    case 'controls_repeat_ext':{
      const times=Math.max(0, numFromInput(b,'TIMES',1));
      const inner=[]; const first=b.getInputTargetBlock('DO'); walkChain(first, inner);
      list.push({type:'FOR',count:times,body:inner}); break; }
    case 'controls_if':{
      const branches=[]; let i=0;
      while(b.getInput('IF'+i)){
        const cb = b.getInputTargetBlock('IF'+i);
        const cond = exprFromBlock(cb);
        const condAst = condFromBlock(cb);
        const inner=[]; const first=b.getInputTargetBlock('DO'+i); walkChain(first, inner);
        branches.push({cond, condAst, body:inner}); i++;
      }
      if(b.getInput('ELSE')){
        const inner=[]; const first=b.getInputTargetBlock('ELSE'); walkChain(first, inner);
        branches.push({cond:null, condAst:null, body:inner});
      }
      list.push({type:'IF',branches}); break;
    }
    case 'wait_seconds':{ const s=numFromInput(b,'SEC',1); if(s>0) list.push({type:'W',args:[s*1000]}); break; }
    case 'control_wait_until':{
      const cb=b.getInputTargetBlock('COND'); const cond=exprFromBlock(cb); const condAst=condFromBlock(cb);
      list.push({type:'WAIT_UNTIL',cond,condAst}); break; }
    case 'control_repeat_until':{
      const cb=b.getInputTargetBlock('COND'); const cond=exprFromBlock(cb); const condAst=condFromBlock(cb);
      const inner=[]; const first=b.getInputTargetBlock('DO'); walkChain(first, inner);
      list.push({type:'REPEAT_UNTIL',cond,condAst,body:inner}); break; }
  }
}
function walkChain(start, list){ for(let n=start; n; n=n.getNextBlock()) walkNode(n, list); }

function normalizeProgram(list){
  const out=[];
  

  for(const ins of list){
    if(ins.type==='CMD'){
      const prev=out[out.length-1];
      if(prev && prev.type==='CMD' && prev.s===ins.s) continue;
    }else if(ins.type==='W'){
      if(!Number.isFinite(ins.args?.[0])||ins.args[0]<=0) continue;
      const prev=out[out.length-1];
      if(prev && prev.type==='W'){ prev.args[0]+=ins.args[0]; continue; }
    }
    out.push(ins);
  }
  return out;
}

function firstExecutableTopStack(){
  const tops=ws.getTopBlocks(true);
  for(const b of tops){
    if(!b.outputConnection&&(b.nextConnection||b.statementInputCount>0||b.type==='xrobo_start')) return b;
  }
  return null;
}

function blocksToProgram(){
  const starts=ws.getBlocksByType('xrobo_start',true);
  let entry=null, startChain=null;
  if(starts.length){ entry=starts[0]; startChain=entry.getNextBlock(); }
  else{ entry=firstExecutableTopStack(); startChain=entry; }
  if(!entry) return [];
  const prog=[]; walkChain(startChain, prog);
  return normalizeProgram(prog);
}

/* === C코드 미리보기 생성 (변수 선언 + SETVAR 지원 추가, 나머지 로직 유지) === */
function programToC(prog){
  // 변수 선언부(int ...)를 최상단에 출력
  const decls=[];
  try{
    const names=getAllVarNames();
    for(const n of names){ decls.push(`int ${cIdent(n)} = 0;`); }
  }catch(_){}
  const out=[...decls, '', 'void setup() {','  // TODO: 핀 초기화','}','', 'void loop() {'];
  const emit=(list,indent='  ')=>{
    for(const ins of list){
      if(ins.type==='CMD'){ out.push(`${indent}send("${ins.s}");`); }
      else if(ins.type==='W'){ out.push(`${indent}delay(${ins.args[0]});`); }
      else if(ins.type==='SETVAR'){ out.push(`${indent}${cIdent(ins.name)} = (${ins.valExpr||'0'});`); }
      else if(ins.type==='FOR'){ out.push(`${indent}for (int i=0; i<${ins.count}; ++i) {`); emit(ins.body,indent+'  '); out.push(`${indent}}`); }
      else if(ins.type==='IF'){
        let first=true;
        for(const br of ins.branches){
          out.push(`${indent}${br.cond!==null?(first?'if':'else if'):'else'} ${br.cond!==null?`(${br.cond}) `:''}{`);
          first=false; emit(br.body,indent+'  '); out.push(`${indent}}`);
        }
      }
      else if(ins.type==='LOOP_INF'){ out.push(`${indent}while(true){`); emit(ins.body,indent+'  '); out.push(`${indent}}`); }
      else if(ins.type==='WAIT_UNTIL'){ out.push(`${indent}while (!(${ins.cond||'/* cond */'})) { delay(50); }`); }
      else if(ins.type==='REPEAT_UNTIL'){ out.push(`${indent}while (!(${ins.cond||'/* cond */'})) {`); emit(ins.body,indent+'  '); out.push(`${indent}  delay(50);`); out.push(`${indent}}`); }
    }
  };
  emit(prog,'  '); out.push('}'); 
  return out.join('\n');
}

/* 코드뷰 갱신 */
const codeView=document.getElementById('rightTop');
let refreshTimer=null;
function refreshCodeDebounced(){ 
  clearTimeout(refreshTimer); 
  refreshTimer=setTimeout(()=>{ 
    // 혹시 문자열에 "\\n"이 들어왔다면 실제 줄바꿈으로 교체
    const c = programToC(blocksToProgram());
    codeView.textContent = String(c).replace(/\\n/g, '\n');
  },100); 
}
ws.addChangeListener(refreshCodeDebounced); refreshCodeDebounced();

/* === 기본 변수 'AAA' 생성 & 새 변수블록 기본값을 AAA로 === */
(function ensureDefaultAAA(){
  try{
    const hasAAA = (ws.getAllVariables?.()||[]).some(v=>v.name==='AAA');
    if(!hasAAA){ ws.createVariable('AAA'); }
  }catch(_){}
  ws.addChangeListener(ev=>{
    if(!ev || ev.type !== Blockly.Events.BLOCK_CREATE) return;
    const AAA = (ws.getAllVariables?.()||[]).find(v=>v.name==='AAA') || ws.createVariable('AAA');
    const ids = ev.ids || [];
    for(const id of ids){
      const b = ws.getBlockById(id);
      if(!b) continue;
      if(b.type==='variables_set' || b.type==='math_change' || b.type==='variables_get'){
        try{ b.setFieldValue(AAA.getId(), 'VAR'); }catch(_){}
      }
    }
  });
})();

/* ================= 헤더/스케일/풀스크린 ================= */
function applyHeaderHeight(){
  const px = document.getElementById('appHeader').offsetHeight || 64;
  document.documentElement.style.setProperty('--headerH', px+'px');
  setTimeout(()=>Blockly.svgResize(ws), 60);
}
function applyUiScaleFromWorkspace(){
  const s = Math.max(.7, Math.min(1.6, ws.getScale()));
  document.documentElement.style.setProperty('--uiScale', s);
  applyHeaderHeight();
}
window.addEventListener('resize', applyHeaderHeight);
document.addEventListener('fullscreenchange', applyHeaderHeight);
ws.addChangeListener(ev=>{
  if(ev && ev.type===Blockly.Events.UI && ev.element==='zoom'){ applyUiScaleFromWorkspace(); }
});
setInterval(()=>applyUiScaleFromWorkspace(), 200);
applyUiScaleFromWorkspace();
applyHeaderHeight();

/* ================= BLE & 실행 & 실시간 ================= */
const SERVICE_UUID=0xFFF0;
let rtVars = {};

let bleDevice=null,bleServer=null,bleService=null,writeChar=null,notifyChar=null;
let connectToken=0;
let runToken=0;
let isConnected=false, isRunning=false;
let realTime=false; // 실시간 전송

const $=id=>document.getElementById(id);
const log=m=>{ const L=$('log'); L.textContent+=m+"\n"; L.scrollTop=L.scrollHeight; };
const btnConnect=$('connectToggle'), btnRun=$('runToggle'), dot=$('statusDot');
const btnRt=$('rtToggle');
const enc=s=>new TextEncoder().encode(s);

function resetBleRefs(){ bleDevice=null; bleServer=null; bleService=null; writeChar=null; notifyChar=null; }
function setConnected(v){
  isConnected=v;
  btnConnect.textContent=v?'해제':'연결';
  btnRun.disabled=!v;
  dot.classList.toggle('on',v); dot.classList.toggle('off',!v);
  dot.textContent=v?'on':'off';
  if(!v) setRunning(false);
}
function setRunning(v){
  isRunning=v;
  btnRun.textContent=v?'■ 정지':'▶ 실행';
  btnRun.style.background = v ? '#ef4444' : '#16a34a';
}
function setRealtime(on){
  realTime=!!on;
  btnRt.classList.toggle('on', realTime);
  btnRt.textContent = realTime ? '실시간: ON' : '실시간: OFF';
}
btnRt.addEventListener('click', ()=>{
  setRealtime(!realTime);
  if(servoModal.classList.contains('show')){
    realTime ? rtStartTicker() : rtStopTicker();
  }
});
async function sendImmediate(s){
  if(!realTime) return;
  if(!writeChar) return;
  try{ await writeChar.writeValue(enc(s+'\n')); log('➡️ '+s); }
  catch(e){ console.error(e); log('⚠️ 전송 실패: '+e); }
}

function onDisconnected(ev){
  if(bleDevice && ev?.target && ev.target !== bleDevice) return;
  log('🔌 해제됨');
  setConnected(false); resetBleRefs();
}

async function connectBLE(){
  if(!navigator.bluetooth){ alert('이 브라우저는 Web Bluetooth 미지원입니다.'); return; }
  const myToken=++connectToken;
  try{
    const dev = await navigator.bluetooth.requestDevice({
      filters:[{ namePrefix:'XROBO' }],
      optionalServices:[SERVICE_UUID, 0xFFF3, 0xFFF4]
    });
    if(connectToken!==myToken) return;
    try{ bleDevice?.removeEventListener('gattserverdisconnected', onDisconnected); }catch(_){}
    resetBleRefs();
    bleDevice=dev;
    bleDevice.addEventListener('gattserverdisconnected', onDisconnected);

    bleServer=await bleDevice.gatt.connect();
    if(connectToken!==myToken) return;
    bleService=await bleServer.getPrimaryService(SERVICE_UUID);

    try{ writeChar=await bleService.getCharacteristic(0xFFF3);}catch(_){}
    try{ notifyChar=await bleService.getCharacteristic(0xFFF4);}catch(_){}
    if(!writeChar || notifyChar==null){
      const cs=await bleService.getCharacteristics();
      for(const ch of cs){
        const p=ch.properties;
        if(!writeChar && (p.write||p.writeWithoutResponse)) writeChar=ch;
        if(!notifyChar && p.notify) notifyChar=ch;
      }
    }
    if(!writeChar) throw new Error('write 특성을 찾지 못했습니다.');
    if(notifyChar){
      await notifyChar.startNotifications();
      notifyChar.addEventListener('characteristicvaluechanged',ev=>{ const v=new TextDecoder().decode(ev.target.value); log('⬅️ '+v); onBleChunk(v); });
    }
    if(connectToken!==myToken) return;
    setConnected(true);
    log('✅ 연결: '+(dev.name||'(이름 없음)'));
  }catch(e){
    console.error(e); log('❌ 연결 실패: '+e);
    setConnected(false); resetBleRefs();
  }
}
function disconnectBLE(){
  try{ bleDevice?.gatt?.disconnect(); }catch(_){}
  setConnected(false); resetBleRefs(); ++connectToken;
}
btnConnect.onclick = ()=>{ isConnected ? disconnectBLE() : connectBLE(); };

/* 실행 루프 */
async function sendCmdIfActive(s, myRun){
  if(myRun.canceled()) return;
  if(!writeChar) throw new Error('BLE 미연결');
  await writeChar.writeValue(enc(s+'\n'));
  log('➡️ '+s);
}
async function sleepCancelable(ms, myRun){
  let remain = Math.max(0, ms);
  while(remain > 0){
    if(myRun.canceled()) return;
    const slice = Math.min(50, remain);
    await new Promise(r=>setTimeout(r, slice));
    remain -= slice;
  }
}
btnRun.onclick = async ()=>{
  if(!isRunning){
    if(!writeChar){ alert('먼저 BLE 연결!'); return; }
    setRunning(true);
    const prog = blocksToProgram();
    if(!prog.length){ alert('실행할 블록이 없습니다.\n"XROBO start" 또는 최상단 스택을 배치하세요.'); setRunning(false); return; }
    const myRunId = ++runToken;
    const myRun = { canceled: ()=> myRunId !== runToken || !isRunning };
    // 변수 런타임 초기화(기본 0)
    rtVars = {};
    

    const runLoop = async(list)=>{
      for(let i=0;i<list.length;i++){
        if(myRun.canceled()) return;
        const ins=list[i];
        if(ins.type==='CMD'){
          await sendCmdIfActive(ins.s, myRun);
        }
        else if(ins.type==='W'){
          await sleepCancelable(ins.args[0], myRun);
        }
        else if(ins.type==='SETVAR'){
          try{
            const v = Number(numEval(ins.valAst)) || 0;
            rtVars[ins.name] = v;
          }catch(e){ console.error(e); log('⚠️ 변수 대입 오류: '+e); }
        }
        else if(ins.type==='FOR'){
          for(let k=0; k<ins.count; k++){
            if(myRun.canceled()) return;
            await runLoop(ins.body);
          }
        }
        else if(ins.type==='IF'){
          for(const br of ins.branches){
            if(myRun.canceled()) return;
            if(br.condAst==null){ // else
              await runLoop(br.body); break;
            }else{
              try{
                const ok = await boolEval(br.condAst);
                if(ok){ await runLoop(br.body); break; }
              }catch(e){
                console.error(e); log('⚠️ IF 조건 평가 오류: '+e);
              }
            }
          }
        }
        else if(ins.type==='WAIT_UNTIL'){
          try{
            while(!myRun.canceled()){
              const ok = await boolEval(ins.condAst);
              if(ok) break;
              await sleepCancelable(50, myRun);
            }
          }catch(e){
            console.error(e); log('⚠️ WAIT_UNTIL 평가 오류: '+e);
          }
        }
        else if(ins.type==='REPEAT_UNTIL'){
          try{
            while(!myRun.canceled()){
              await runLoop(ins.body);
              const stop = await boolEval(ins.condAst);
              if(stop) break;
              await sleepCancelable(20, myRun);
            }
          }catch(e){
            console.error(e); log('⚠️ REPEAT_UNTIL 평가 오류: '+e);
          }
        }
        else if(ins.type==='LOOP_INF'){
          while(!myRun.canceled()){
            await runLoop(ins.body);
          }
        }
      }
    };

    try{ await runLoop(prog); }
    catch(e){ console.error(e); log('⚠️ 실행 오류: '+e); }
    finally{ if(!myRun.canceled()) setRunning(false); }
  }else{
    setRunning(false);
    runToken++;
    try{ if(writeChar) await writeChar.writeValue(enc('S\n')); }catch(_){}
  }
};

/* 실행창 토글 핸들 */
const panelHandle=document.getElementById('panelHandle');
function syncHandle(){
  const collapsed = document.body.classList.contains('panel-collapsed');
  panelHandle.classList.toggle('open',   !collapsed);
  panelHandle.classList.toggle('closed',  collapsed);
  panelHandle.title = collapsed ? '실행창 열기' : '실행창 닫기';
}
function togglePanel(){ document.body.classList.toggle('panel-collapsed'); syncHandle(); setTimeout(()=>Blockly.svgResize(ws),60); }
panelHandle.addEventListener('click', togglePanel);
syncHandle();

/* 전체화면 토글 */
const fsBtn=document.getElementById('fsBtn');
async function enterFS(){ const el=document.documentElement; if(el.requestFullscreen) await el.requestFullscreen(); }
async function exitFS(){ if(document.fullscreenElement && document.exitFullscreen) await document.exitFullscreen(); }
function syncFSLabel(){
  const a = !!document.fullscreenElement;
  document.body.classList.toggle('fs-active', a);
  fsBtn.textContent = a ? '화면축소' : '전체화면';
  fsBtn.title = a ? '화면 축소로 전환' : '전체화면으로 전환';
  applyHeaderHeight();
}
fsBtn.onclick=async()=>{ if(document.fullscreenElement) await exitFS(); else await enterFS(); };
document.addEventListener('fullscreenchange', syncFSLabel);
syncFSLabel();

/* ================= 멀티 서보 설정 모달 구현 ================= */
const servoModal = document.getElementById('servoModal');
const boardEl = document.getElementById('board');
const stageEl = document.getElementById('boardStage');
const addServoBtn = document.getElementById('addServoBtn');
const applyBgBtn = document.getElementById('applyBg');
const bgUrlInput = document.getElementById('bgUrl');
const closeModalBtn = document.getElementById('closeModal');

// === 0.1s 간격 실시간 전송(멀티 서보 모달 전용) ===
let rtTimer = null;
let rtPrev = new Map();

function rtStartTicker(){
  if(rtTimer) return;
  rtTimer = setInterval(rtTick, 100); // 0.1초
}
function rtStopTicker(){
  if(rtTimer){ clearInterval(rtTimer); rtTimer = null; }
  rtPrev.clear();
}
function collectUnitsSnapshot(){
  const list = [];
  try{
    const nodes = stageEl.querySelectorAll('.unit');
    nodes.forEach(u=>{
      const name = u.dataset.name || 'S1';
      const inp  = u.querySelector('.numbox input');
      const spd  = u.querySelector('.speedbox input, .speedbox select');
      const on   = !u.querySelector('.pwr-top')?.classList.contains('off');
      const ang  = clampAng180(Number(inp?.value)||90);
      const sp   = (function(v){let n=parseInt(v,10); if(Number.isNaN(n)) n=0; return Math.max(0, Math.min(20, n));})(spd?.value);
      list.push({name, angle:ang, speed:sp, power:on});
    });
  }catch(_){}
  return list;
}
// 변경 감지용 더미(이벤트에서 호출)
function rtMarkDirty(){ /* 주기틱에서 DOM을 읽어 반영 */ }

async function rtTick(){
  if(!realTime || !writeChar) return;
  const snap = collectUnitsSnapshot();
  for(const u of snap){
    const p = rtPrev.get(u.name);
    const changed = !p || p.angle!==u.angle || p.speed!==u.speed || p.power!==u.power;
    if(changed){
      rtPrev.set(u.name, {...u});
      if(u.power){
        try{
          await writeChar.writeValue(enc(`SVS ${u.name} ${u.speed} ${u.angle}\n`));
          log('➡️ ' + `SVS ${u.name} ${u.speed} ${u.angle}`);
        }catch(_){ /* 전송 실패 무시 */ }
      }
    }
  }
}


let currentBlock = null;
let unitSeq = 0;
const clamp=(v,min,max)=>Math.min(max,Math.max(min,v));
const toRad=d=>d*Math.PI/180;
const toDeg=r=>r*180/Math.PI;

/* 다이얼 각도 보정 */
const valToScreenDeg = v => v;
function nearestAngle(target, reference){
  const c=[target-360, target, target+360]; let best=c[0], bd=Math.abs(c[0]-reference);
  for(const x of c){ const d=Math.abs(x-reference); if(d<bd){ bd=d; best=x; } } return best;
}
function projectToArcWithSide(rawDeg, dx, lastScrDeg){
  let a = ((rawDeg%360)+360)%360; if(a>180) a-=360;
  a = nearestAngle(a, lastScrDeg);
  if(a >= -45 && a <= 225) return a;
  return dx >= 0 ? -45 : 225;
}

const UNIT_SCALE = 0.7;
const TOP_MARGIN = Math.round(46 * UNIT_SCALE);

function createUnit(state){
  const {name} = state;
  const unit = document.createElement('div');
  unit.className='unit'; unit.style.left=(state.x ?? 12)+'px'; unit.style.top=(state.y ?? 56)+'px'; unit.dataset.name=name;

  const handle = document.createElement('div'); handle.className='handle'; handle.textContent=name;
  const pwrTop = document.createElement('div'); pwrTop.className='pwr-top'+(state.power? '' : ' off'); pwrTop.textContent=state.power?'ON':'OFF';
  const delTop = document.createElement('div'); delTop.className='trash-top'; delTop.title='삭제'; delTop.textContent='🗑';
delTop.addEventListener('click', (e)=>{ e.stopPropagation(); try{ unit.remove(); if(currentBlock){ const cfg = multiServoConfigs.get(currentBlock.id) || {units:[]}; const i = cfg.units.findIndex(u=>u.name===name); if(i>=0) cfg.units.splice(i,1); currentBlock.setFieldValue(String(cfg.units.length), 'COUNT'); multiServoConfigs.set(currentBlock.id, cfg);} }catch(_){}
});
handle.appendChild(delTop);
handle.appendChild(pwrTop); unit.appendChild(handle);
  // === 추가: 서보 번호 드롭다운 (S1~S20) ===
  const sel = document.createElement('select'); sel.className='sno-select'; sel.title='서보 번호 선택';
  for(let i=1;i<=20;i++){ const o=document.createElement('option'); const nm='S'+i; o.value=nm; o.textContent=nm; sel.appendChild(o); }
  sel.value = name;
  sel.addEventListener('change', ()=>{ 
    unit.dataset.name = sel.value; 
    state.name = sel.value; 
  });
  handle.appendChild(sel);


  const row = document.createElement('div'); row.className='row';
  const num = document.createElement('div'); num.className='numbox';
  const inp = document.createElement('input'); inp.type='number'; inp.min='0'; inp.max='180'; inp.step='1'; inp.value=String(clampAng180(state.angle ?? 90)); inp.title='서보 각도(0~180°)';
  num.appendChild(inp);
  const spdBox = document.createElement('div'); spdBox.className='speedbox';
const spdSel = document.createElement('select');
for(let i=0;i<=20;i++){ const o=document.createElement('option'); o.value=String(i); o.textContent=String(i); spdSel.appendChild(o); }
spdSel.value = String(Math.max(0, Math.min(20, (state.speed ?? 0))));
spdSel.title='이동 속도(0~20: 클수록 빠름)';
spdSel.addEventListener('change', rtMarkDirty);
spdBox.appendChild(spdSel);
row.append(num, spdBox); unit.appendChild(row);

  const svgNS='http://www.w3.org/2000/svg';
  const svg = document.createElementNS(svgNS,'svg');
  svg.setAttribute('class','dial-svg'); svg.setAttribute('viewBox','0 0 100 100'); svg.setAttribute('tabindex','0');

  const defs = document.createElementNS(svgNS,'defs');
  const gradId='gDot_'+name;
  const grad=document.createElementNS(svgNS,'radialGradient');
  grad.setAttribute('id',gradId); grad.setAttribute('cx','30%'); grad.setAttribute('cy','30%');
  let s1=document.createElementNS(svgNS,'stop'); s1.setAttribute('offset','0%'); s1.setAttribute('stop-color','#e0edff');
  let s2=document.createElementNS(svgNS,'stop'); s2.setAttribute('offset','45%'); s2.setAttribute('stop-color','#93c5fd');
  let s3=document.createElementNS(svgNS,'stop'); s3.setAttribute('offset','100%'); s3.setAttribute('stop-color','#3b82f6');
  grad.append(s1,s2,s3); defs.appendChild(grad); svg.appendChild(defs);

  const ring=document.createElementNS(svgNS,'circle');
  ring.setAttribute('class','ring-base'); ring.setAttribute('cx','50'); ring.setAttribute('cy','50'); ring.setAttribute('r','40');
  svg.appendChild(ring);

  const mkTick = ()=>document.createElementNS(svgNS,'line');
  const tickL=mkTick(), tickT=mkTick(), tickR=mkTick();
  tickL.setAttribute('class','tick'); tickT.setAttribute('class','tick'); tickR.setAttribute('class','tick');
  svg.append(tickL,tickT,tickR);

  const dot=document.createElementNS(svgNS,'circle');
  dot.setAttribute('class','dot blue'); dot.setAttribute('r','5.4'); dot.setAttribute('fill', `url(#${gradId})`);
  svg.appendChild(dot);

  unit.appendChild(svg);
  stageEl.appendChild(unit);

  state.els = {unit, handle, pwrTop, row, inp, spdSel, svg, ring, tickL, tickT, tickR, dot, gradId};
  state.angle = clampAng180(state.angle ?? 90);
  state.speed = Math.max(0, Math.min(20, state.speed ?? 10));
  state.lastScrDeg = valToScreenDeg(state.angle);

  function layoutTicks(){
    const R=40, S=2, Rout=R+S/2, OUTSET=3, L=8, R1=Rout+OUTSET, R2=R1+L, CX=50, CY=50;
    function setTick(el,deg){ const a=toRad(deg);
      const x1=CX+R1*Math.cos(a), y1=CY-R1*Math.sin(a);
      const x2=CX+R2*Math.cos(a), y2=CY-R2*Math.sin(a);
      el.setAttribute('x1',x1); el.setAttribute('y1',y1); el.setAttribute('x2',x2); el.setAttribute('y2',y2);
    }
    setTick(state.els.tickL,180);
    setTick(state.els.tickT, 90);
    setTick(state.els.tickR,  0);
  }
  function placeDot(){
    if(!state.els.dot.classList.contains('red')) state.els.dot.setAttribute('fill', `url(#${state.els.gradId})`);
    const R=30, a=toRad(valToScreenDeg(state.angle));
    const x=50+R*Math.cos(a), y=50-R*Math.sin(a);
    state.els.dot.setAttribute('cx',x); state.els.dot.setAttribute('cy',y);
  }
  function render(){ state.els.inp.value=Math.round(state.angle); state.els.spdSel.value=String(state.speed); placeDot(); }
  layoutTicks(); render();

  const stopProp = ev => ev.stopPropagation();
  state.els.pwrTop.addEventListener('mousedown', stopProp);
  state.els.pwrTop.addEventListener('touchstart', stopProp, {passive:false});
  state.els.pwrTop.addEventListener('click', ev=>{
    ev.stopPropagation();
    state.power = !state.power;
    state.els.pwrTop.classList.toggle('off', !state.power);
    state.els.pwrTop.textContent = state.power?'ON':'OFF';
    if(state.power){
      rtMarkDirty();
    }
    render();
  });

  state.els.inp.addEventListener('change', ()=>{
    const v=Number(state.els.inp.value);
    if(Number.isFinite(v)){
      state.angle=clampAng180(v);
      render();
      rtMarkDirty();
    }else{
      state.els.inp.value=String(clampAng180(state.angle));
    }
  });
  state.els.spdSel.addEventListener('change', ()=>{
    state.speed = Math.max(0, Math.min(20, parseInt(state.els.spdSel.value||'10',10)|| 0));
    render();
    rtMarkDirty();
  });

  function setDotActive(on){
    state.els.dot.classList.toggle('red', !!on);
    state.els.dot.classList.toggle('blue', !on);
    if(!on) state.els.dot.setAttribute('fill', `url(#${state.els.gradId})`);
  }
  function pointToVal(clientX, clientY){
    const r=state.els.svg.getBoundingClientRect();
    const cx=r.left+r.width/2, cy=r.top+r.height/2;
    const dx=clientX-cx, dy=cy-clientY;
    const raw = toDeg(Math.atan2(dy, dx));
    const scr = projectToArcWithSide(raw, dx, state.lastScrDeg);
    state.lastScrDeg = scr;
    return Math.max(0, Math.min(180, Math.round(scr)));
  }
  function dialDown(e){
    if(!state.power) return;
    setDotActive(true);
    const p=('touches' in e)?e.touches[0]:e;
    state.angle = pointToVal(p.clientX, p.clientY);
    render(); rtMarkDirty();
    window.addEventListener('mousemove', dialMove);
    window.addEventListener('touchmove', dialMove, {passive:false});
    window.addEventListener('mouseup', dialUp, {once:true});
    window.addEventListener('touchend', dialUp, {once:true});
  }
  function dialMove(e){
    if(!state.power) return;
    const p=('touches' in e)?e.touches[0]:e;
    if('touches' in e) e.preventDefault();
    state.angle = pointToVal(p.clientX, p.clientY);
    render(); rtMarkDirty();
  }
  function dialUp(){
    setDotActive(false);
    window.removeEventListener('mousemove', dialMove);
    window.removeEventListener('touchmove', dialMove);
  }
  state.els.svg.addEventListener('mousedown', dialDown);
  state.els.svg.addEventListener('touchstart', dialDown, {passive:false});
  state.els.svg.addEventListener('wheel', e=>{
    if(!state.power) return; e.preventDefault();
    const d=Math.sign(e.deltaY);
    state.angle=clampAng180(state.angle - d*1); render(); rtMarkDirty();
  }, {passive:false});

  function unitDown(e){
    if(e.currentTarget !== state.els.handle) return;
    if(e.target.closest('.pwr-top') || e.target.closest('.trash-top')) return;
    const rect=state.els.unit.getBoundingClientRect();
    const p=('touches' in e)?e.touches[0]:e;
    const dragDx=p.clientX-rect.left, dragDy=p.clientY-rect.top;
    state.els.unit.classList.add('dragging');
    const move = ev=>{
      const q=('touches' in ev)?ev.touches[0]:ev; if('touches' in ev) ev.preventDefault();
      const b=stageEl.getBoundingClientRect();
      let nx=q.clientX-b.left-dragDx, ny=q.clientY-b.top-dragDy;
      nx=clamp(nx,0,b.width-state.els.unit.offsetWidth);
      ny=clamp(ny,TOP_MARGIN,b.height-state.els.unit.offsetHeight);
      state.els.unit.style.left=nx+'px'; state.els.unit.style.top=ny+'px';
    };
    const up = ()=>{
      state.els.unit.classList.remove('dragging');
      window.removeEventListener('mousemove', move);
      window.removeEventListener('touchmove', move);
    };
    window.addEventListener('mousemove', move);
    window.addEventListener('touchmove', move, {passive:false});
    window.addEventListener('mouseup', up, {once:true});
    window.addEventListener('touchend', up, {once:true});
    state.els.unit.style.zIndex = String(Math.floor(Date.now()/1000));
  }
  state.els.handle.addEventListener('mousedown', unitDown);
  state.els.handle.addEventListener('touchstart', unitDown, {passive:false});
}

/* 모달 열기/닫기/저장 */
function openServoModal(block){
  currentBlock = block;
  stageEl.innerHTML = '';
  unitSeq = 0;

  let cfg = multiServoConfigs.get(block.id);
  if(!cfg){
    cfg = { bgUrl:'', units:[] };
    multiServoConfigs.set(block.id, cfg);
  }
  stageEl.style.backgroundImage = cfg.bgUrl ? `url("${cfg.bgUrl}")` : '';
  bgUrlInput.value = cfg.bgUrl || '';

  if(cfg.units.length === 0){
    cfg.units.push({name:'S1', angle:90, speed:0, power:true, x:12, y:56});
  }
  cfg.units.forEach(u => createUnit(u));

  setRealtime(realTime);
  servoModal.classList.add('show');
  servoModal.setAttribute('aria-hidden','false');
}
function closeServoModalAndSave(){
  if(!currentBlock) return;
  const cfg = multiServoConfigs.get(currentBlock.id) || {bgUrl:'', units:[]};
  cfg.bgUrl = bgUrlInput.value.trim();
  cfg.units = Array.from(stageEl.querySelectorAll('.unit')).map(u=>{
    const name = u.dataset.name;
    const inp = u.querySelector('.numbox input');
    const spd = u.querySelector('.speedbox input, .speedbox select');
    const on  = !u.querySelector('.pwr-top').classList.contains('off');
    return {
      name,
      angle: clampAng180(Number(inp.value)||90),
      speed: Math.max(0, Math.min(20, (function(v){var n=parseInt(v,10);return Number.isNaN(n)?0:n;})(spd?.value))),
      power: on,
      x: parseInt(u.style.left)||12,
      y: parseInt(u.style.top)||56
    };
  });
  multiServoConfigs.set(currentBlock.id, cfg);
  currentBlock.setFieldValue(String(cfg.units.length), 'COUNT');

  stageEl.style.backgroundImage = cfg.bgUrl ? `url("${cfg.bgUrl}")` : '';

  servoModal.classList.remove('show');
  servoModal.setAttribute('aria-hidden','true');
  currentBlock = null;
}

addServoBtn.addEventListener('click', ()=>{
  if(!currentBlock) return;
  const cfg = multiServoConfigs.get(currentBlock.id) || {bgUrl:'', units:[]};
  const idx = cfg.units.length+1;
  const name = 'S'+idx;
  const baseX = 12, baseY = 56, stepX = Math.round(16*UNIT_SCALE), stepY = Math.round(20*UNIT_SCALE);
  const x = baseX + (unitSeq%20)*stepX; unitSeq++;
  const y = baseY + Math.floor(unitSeq/20)*stepY;
  const st = {name, angle:90, speed:0, power:true, x, y};
  cfg.units.push(st);
  createUnit(st);
});
applyBgBtn.addEventListener('click', ()=>{
  const url=(bgUrlInput.value||'').trim();
  stageEl.style.backgroundImage = url ? `url("${url}")` : '';
});
closeModalBtn.addEventListener('click', closeServoModalAndSave);
servoModal.addEventListener('click', (e)=>{ if(e.target===servoModal) closeServoModalAndSave(); });

/* ================= 저장 / 불러오기 ================= */
const btnSave=$('saveBtn'), btnLoad=$('loadBtn');

function textToDomCompat(xmlText){
  if (Blockly.Xml && typeof Blockly.Xml.textToDom === 'function') return Blockly.Xml.textToDom(xmlText);
  if (Blockly.utils && Blockly.utils.xml && typeof Blockly.utils.xml.textToDom === 'function') return Blockly.utils.xml.textToDom(xmlText);
  const parser = new DOMParser();
  const doc = parser.parseFromString(xmlText, 'text/xml');
  const perr = doc.getElementsByTagName('parsererror')[0];
  if (perr) throw new Error('XML 파싱 오류');
  return doc;
}
function domToTextCompat(dom){
  if (Blockly.Xml && typeof Blockly.Xml.domToText === 'function') return Blockly.Xml.domToText(dom);
  if (Blockly.utils && Blockly.utils.xml && typeof Blockly.utils.xml.domToText === 'function') return Blockly.utils.xml.domToText(dom);
  return new XMLSerializer().serializeToString(dom);
}
function workspaceToDomCompat(workspace){
  if (Blockly.Xml && typeof Blockly.Xml.workspaceToDom === 'function') return Blockly.Xml.workspaceToDom(workspace);
  return null;
}
function domToWorkspaceCompat(dom, workspace){
  if (Blockly.Xml && typeof Blockly.Xml.domToWorkspace === 'function') return Blockly.Xml.domToWorkspace(dom, workspace);
  throw new Error('이 Blockly 빌드는 XML 로더(domToWorkspace)를 지원하지 않습니다.');
}
function workspaceSaveJsonCompat(workspace){
  if (Blockly.serialization && Blockly.serialization.workspaces && typeof Blockly.serialization.workspaces.save === 'function'){
    return Blockly.serialization.workspaces.save(workspace);
  }
  return null;
}
function workspaceLoadJsonCompat(state, workspace){
  if (Blockly.serialization && Blockly.serialization.workspaces && typeof Blockly.serialization.workspaces.load === 'function'){
    Blockly.serialization.workspaces.load(state, workspace);
    return true;
  }
  return false;
}

function ts(){
  const d=new Date();
  const pad=n=>String(n).padStart(2,'0');
  return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
}
function buildProjectPayload(){
  if(servoModal.classList.contains('show')) closeServoModalAndSave();

  let xmlText = null;
  const dom = workspaceToDomCompat(ws);
  if(dom) xmlText = domToTextCompat(dom);

  const jsonState = workspaceSaveJsonCompat(ws);

  const entries = {};
  for(const [k,v] of multiServoConfigs.entries()){
    entries[k] = { bgUrl: v.bgUrl||'', units: (v.units||[]).map(u=>({
      name: u.name, angle: clampAng180(u.angle), speed: Math.max(0, Math.min(20, u.speed|| 0)), power: !!u.power, x: u.x, y: u.y
    }))};
  }

  return {
    format: 'xrobo-ble-v1',
    time: new Date().toISOString(),
    workspaceXml: xmlText,
    workspaceJson: jsonState,
    multiServoConfigs: entries,
    ui: { realTime }
  };
}
function fallbackDownload(filename, text, type='application/json'){
  const blob=new Blob([text],{type});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url; a.download=filename; document.body.appendChild(a); a.click();
  setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
}

async function saveProject(){
  // Build payload once
  const data = buildProjectPayload();
  const json = JSON.stringify(data, null, 2);
  const defaultName = `xrobo_project_${ts()}.xrobo.json`;

  // Helper: safe download fallback
  const doFallback = (name = defaultName)=>{
    try{
      fallbackDownload(name, json);
      log('💾 저장 완료(다운로드)');
    }catch(e){
      console.error(e);
      alert('저장 실패: ' + (e?.message || e));
    }
  };

  // Try File System Access API first (if available & allowed)
  try{
    if (window.showSaveFilePicker){
      try{
        const handle = await window.showSaveFilePicker({
          suggestedName: defaultName,
          types: [{ description: 'XROBO Project', accept: { 'application/json': ['.xrobo.json'] } }]
        });
        const stream = await handle.createWritable();
        await stream.write(json);
        await stream.close();
        log('💾 저장 완료');
        return;
      }catch(err){
        // User canceled or API blocked -> graceful fallback
        console.warn('showSaveFilePicker 실패, 다운로드로 폴백:', err);
        doFallback();
        return;
      }
    }
  }catch(e){
    console.warn('File System Access API 사용 불가, 다운로드로 폴백:', e);
    // fall through to fallback
  }

  // Final fallback for 모든 브라우저(모바일/iOS 포함)
  doFallback();
}

async function loadProject(){
  if(servoModal.classList.contains('show')){
    servoModal.classList.remove('show');
    servoModal.setAttribute('aria-hidden','true');
    currentBlock=null;
  }

  try{
    let file;
    if(window.showOpenFilePicker){
      const [handle] = await window.showOpenFilePicker({
        types: [{ description: 'XROBO Project', accept: { 'application/json': ['.xrobo.json', '.json'] } }],
        multiple: false
      });
      file = await handle.getFile();
    }else{
      file = await new Promise((resolve, reject)=>{
        const inp=document.createElement('input');
        inp.type='file';
        inp.accept='.xrobo.json,application/json,text/json';
        inp.onchange=async (e)=>{
          const f=e.target.files?.[0];
          if(f) resolve(f); else reject(new Error('파일이 선택되지 않았습니다.'));
        };
        inp.click();
      });
    }

    const txt = await file.text();
    const data = JSON.parse(txt);

    if(!data || data.format!=='xrobo-ble-v1'){
      throw new Error('프로젝트 파일 형식이 올바르지 않습니다.');
    }

    ws.clear();
    multiServoConfigs.clear();

    let loaded = false;
    if (data.workspaceXml && typeof data.workspaceXml === 'string'){
      try{
        const dom = textToDomCompat(data.workspaceXml);
        domToWorkspaceCompat(dom, ws);
        loaded = true;
      }catch(e){
        console.warn('XML 로드 실패, JSON으로 폴백 시도:', e);
      }
    }
    if(!loaded && data.workspaceJson){
      if(!workspaceLoadJsonCompat(data.workspaceJson, ws)){
        throw new Error('이 Blockly 빌드는 JSON 로더를 지원하지 않습니다.');
      }
      loaded = true;
    }
    if(!loaded){
      throw new Error('워크스페이스를 복원할 수 없습니다.');
    }

    if (data.multiServoConfigs && typeof data.multiServoConfigs==='object'){
      for(const [id, cfg] of Object.entries(data.multiServoConfigs)){
        multiServoConfigs.set(id, cfg);
      }
    }

    ws.getAllBlocks(false).forEach(b=>{
      if(b.type==='multi_servo'){
        const n=(multiServoConfigs.get(b.id)?.units?.length)||0;
        b.setFieldValue(String(n), 'COUNT');
      }
    });

    if(data.ui && typeof data.ui.realTime === 'boolean'){
      setRealtime(data.ui.realTime);
    }

    refreshCodeDebounced();
    log('📥 불러오기 완료');
  }catch(err){
    console.error(err);
    alert('불러오기 실패: '+(err?.message||err));
  }
}

(function(el){ if(el) el.addEventListener('click', saveProject); })(document.getElementById('saveBtn'));
(function(el){ if(el) el.addEventListener('click', loadProject); })(document.getElementById('loadBtn'));

/* === 파일 드롭다운 로직(새로만들기/저장하기/불러오기) === */
(function(){
  const btn  = document.getElementById('fileBtn');
  const menu = document.getElementById('fileMenu');
  if(!btn || !menu) return;
  btn.addEventListener('click', (e)=>{ e.stopPropagation(); menu.classList.toggle('show'); menu.setAttribute('aria-hidden', menu.classList.contains('show')?'false':'true'); });
  document.addEventListener('click', ()=>{ menu.classList.remove('show'); menu.setAttribute('aria-hidden','true'); });
  menu.addEventListener('click', (e)=>{
    const cmd = e.target && e.target.getAttribute('data-cmd');
    if(!cmd) return;
    if(cmd==='new'){
      if(confirm('현재 프로젝트를 모두 지우고 새로 만들까요?')){
        try{
          ws.clear(); 
          multiServoConfigs.clear && multiServoConfigs.clear();
          refreshCodeDebounced && refreshCodeDebounced();
          log && log('🆕 새 프로젝트');
        }catch(_){}
      }
    }else if(cmd==='save'){
      try{ saveProject && saveProject(); }catch(_){}
    }else if(cmd==='load'){
      try{ loadProject && loadProject(); }catch(_){}
    }
    menu.classList.remove('show'); menu.setAttribute('aria-hidden','true');
  });
})();


/* === 서보 블록에 '다이얼' 버튼 추가 & 단독 다이얼 열기 === */
function __xrobo_svg_text_btn(label){
  const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 88 30">
    <rect x="1" y="1" width="86" height="28" rx="8" ry="8" fill="#8b5a2b" stroke="#5d3d1d" stroke-width="1"/>
    <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-size="14" font-weight="700" fill="#fff">${label}</text>
  </svg>`;
  return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
}

/* OUTn -> Sn 매핑 (멀티서보 다이얼과 동일 네이밍) */
function __xrobo_out_to_servo_name(out){
  const m = String(out||'').match(/OUT(\d+)/i); 
  const n = m?Math.max(1, Math.min(20, parseInt(m[1],10))):1;
  return 'S' + n;
}

/* 단독 다이얼 모드: 멀티서보 모달을 임시로 사용해 1개 유닛만 띄움(저장 안함) */
function openSingleServoDialByOut(outName, initAngle){
  try{
    const servoName = __xrobo_out_to_servo_name(outName);
    const backup = { html: stageEl.innerHTML, bg: stageEl.style.backgroundImage, block: (typeof currentBlock!=='undefined'? currentBlock : null) };
    currentBlock = null;                 // 저장/닫기 로직이 프로젝트 데이터에 손대지 않도록
    stageEl.innerHTML = '';              // 기존 유닛 임시 비움
    stageEl.style.backgroundImage = '';  // 배경 제거(보다 집중)
    const st = {name:servoName, angle: (Number(initAngle)||90), speed:0, power:true, x:12, y:56};
    createUnit(st);

    // 모달 표시 + 실시간 틱
    servoModal.classList.add('show');
    servoModal.setAttribute('aria-hidden','false');
    if(realTime) rtStartTicker();

    // 닫기(저장 없이 복구)
    function closeDialOnly(ev){
      if(ev && ev.stopImmediatePropagation) ev.stopImmediatePropagation();
      servoModal.classList.remove('show');
      servoModal.setAttribute('aria-hidden','true');
      stageEl.innerHTML = backup.html;
      stageEl.style.backgroundImage = backup.bg || '';
      currentBlock = backup.block;
      rtStopTicker();
      closeModalBtn.removeEventListener('click', closeDialOnly, true);
      servoModal.removeEventListener('click', overlayCloser, true);
    }
    function overlayCloser(e){ if(e.target===servoModal) closeDialOnly(e); }
    // 캡쳐 단계에서 한 번만 가로채 기존 close 핸들러보다 먼저 실행
    closeModalBtn.addEventListener('click', closeDialOnly, {once:true, capture:true});
    servoModal.addEventListener('click', overlayCloser, {once:true, capture:true});
  }catch(e){ console.warn('openSingleServoDial 오류:', e); }
}

/* 블록 초기화 오버라이드: servo 계열 뒤에 다이얼 버튼 추가 */
(function(){
  function attachDialBtnTo(blockType, angleFieldName){
    const blk = Blockly.Blocks[blockType];
    if(!blk || !blk.init || blk.__dial_patched) return;
    const oldInit = blk.init;
    blk.init = function(){
      oldInit.call(this);
      try{
        const img = new Blockly.FieldImage(__xrobo_svg_text_btn('다이얼'), 83, 31, '다이얼');
        const that = this;
        img.setOnClickHandler(function(){
          // 각도 초기값(있다면)도 전달
          let initAng = 90;
          if(angleFieldName){
            const v = that.getFieldValue(angleFieldName);
            initAng = Number(v)||initAng;
          }else{
            // 입력값 형태일 경우 shadow/number에서 가져오기 시도
            const vIn = that.getInputTargetBlock && that.getInputTargetBlock('ANG');
            if(vIn && vIn.type==='math_number'){
              const f = vIn.getFieldValue && vIn.getFieldValue('NUM');
              if(f!=null) initAng = Number(f)||initAng;
            }
          }
          __xrobo_open_inline_servo_dial(that, that.getFieldValue('OUT'), initAng);
        });
        this.appendDummyInput('_DIAL').appendField(img);
        this.setInputsInline(true);
      }catch(e){ console.warn('dial button attach failed for', blockType, e); }
      blk.__dial_patched = true;
    };
  }
  attachDialBtnTo('servo_dd', 'ANG');  // 드롭다운 각도
  attachDialBtnTo('servo_in',  null ); // 수식/값 입력 각도
  attachDialBtnTo('servo_slow', null);
})();


/* ================= 끝 ================= */
// 안전 바인딩: 기존 바인딩이 없을 때만 연결
(function(){
  const sb = document.getElementById('saveBtn');
  if (sb && !sb.dataset.boundSave){
    sb.addEventListener('click', saveProject);
    sb.dataset.boundSave = '1';
  }
  const lb = document.getElementById('loadBtn');
  if (lb && !lb.dataset.boundLoad){
    lb.addEventListener('click', loadProject);
    lb.dataset.boundLoad = '1';
  }

/* --- Android: stronger hook for multi-servo delay inputs so keypad stays open --- */
(function(){
  if(!/Android/i.test(navigator.userAgent||'')) return;
  function tryOpen(e){
    var t = e.target;
    if(!t || !(t.matches && (t.matches('#servoModal .speedbox input') || t.matches('#boardStage .speedbox input')))) return;
    if(e.cancelable !== false){ e.preventDefault(); }
    e.stopPropagation();
    try{ t.blur(); }catch(_){}
    try{ t.setAttribute('inputmode','none'); t.setAttribute('readonly','readonly'); }catch(_){}
    try{
      if(typeof openForInput === 'function'){ requestAnimationFrame(function(){ openForInput(t, null); }); }
    }catch(_){}
    setTimeout(function(){ try{ t.removeAttribute('readonly'); }catch(_){} }, 200);
  }
  document.addEventListener('pointerdown', tryOpen, true);
  document.addEventListener('touchstart', tryOpen, {capture:true, passive:false});
})();
})();
</script>

<script id="xrobo-inline-dial-script">
(function(){
  if (window.__xrobo_inline_dial_defined) return;
  window.__xrobo_inline_dial_defined = true;
  // 슬로우 서보용: 다이얼 닫을 때 지연(DELAY) 입력에 반영
  function applyDelayToBlock(block, delay){
    try{
      if(!block || !block.workspace) return;
      const d = Math.max(0, Math.round(Number(delay)||0));
      if (typeof block.getInput !== 'function') return;
      const input = block.getInput('DELAY');
      if(!input) return;
      const child = block.getInputTargetBlock && block.getInputTargetBlock('DELAY');

      // 연결된 게 숫자 블록이면 값만 갱신
      if (child && child.type === 'math_number') {
        if (typeof child.setFieldValue === 'function') child.setFieldValue(String(d), 'NUM');
        return;
      }
      // 연결된 것이 없거나 shadow라면 숫자 블록을 만들어 연결
      const isShadow = child && typeof child.isShadow === 'function' && child.isShadow();
      if (!child || isShadow){
        const ws = block.workspace;
        const num = ws.newBlock('math_number');
        num.setFieldValue(String(d), 'NUM');
        num.initSvg(); num.render();
        if (input.connection && num.outputConnection) input.connection.connect(num.outputConnection);
        return;
      }
      // 사용자가 직접 수식/변수 블록을 연결한 경우엔 덮어쓰지 않음
    }catch(e){ console.warn('applyDelayToBlock 오류:', e); }
  }

  // 다이얼 닫을 때 블록의 각도 입력(ANG)에 반영
  function applyAngleToBlock(block, angle){
    try{
      if(!block || !block.workspace) return;
      const ang = Math.max(0, Math.min(180, Math.round(Number(angle)||0)));

      // 1) 필드형(servo_dd 호환용) - 남아있다면
      if (typeof block.getField === 'function' && block.getField('ANG')) {
        block.setFieldValue(String(ang), 'ANG');
        return;
      }
      // 2) 값 입력형(servo_in, servo_slow)
      if (typeof block.getInput !== 'function') return;
      const input = block.getInput('ANG');
      if(!input) return;
      const child = block.getInputTargetBlock && block.getInputTargetBlock('ANG');

      // 연결된 게 숫자 블록이면 값만 갱신
      if (child && child.type === 'math_number') {
        if (typeof child.setFieldValue === 'function') child.setFieldValue(String(ang), 'NUM');
        return;
      }
      // 연결된 것이 없거나 shadow라면 숫자 블록을 만들어 연결
      const isShadow = child && typeof child.isShadow === 'function' && child.isShadow();
      if (!child || isShadow){
        const ws = block.workspace;
        const num = ws.newBlock('math_number');
        num.setFieldValue(String(ang), 'NUM');
        num.initSvg(); num.render();
        if (input.connection && num.outputConnection) input.connection.connect(num.outputConnection);
        return;
      }
      // 사용자가 직접 수식/변수 블록을 연결한 경우엔 덮어쓰지 않음
    }catch(e){ console.warn('applyAngleToBlock 오류:', e); }
  }


  function outToServoName(out){
    const m = String(out||'').match(/OUT(\d+)/i);
    const n = m?Math.max(1, Math.min(20, parseInt(m[1],10))):1;
    return 'S'+n;
  }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  const toRad = d => d*Math.PI/180;
  const toDeg = r => r*180/Math.PI;

  function throttle(fn, ms){
    let last = 0, tid = null, lastArgs=null;
    return function(...args){
      const now = Date.now();
      const elapsed = now - last;
      lastArgs=args;
      if(elapsed >= ms){
        last=now;
        fn.apply(this, args);
      }else{
        clearTimeout(tid);
        tid=setTimeout(()=>{ last=Date.now(); fn.apply(this, lastArgs); }, ms-elapsed);
      }
    };
  }

  function placeNearBlock(pop, block){
    try{
      const root = block.getSvgRoot();
      const r = root.getBoundingClientRect();
      const left = Math.round(r.right + 8 + window.scrollX);
      const top  = Math.round(r.top   + window.scrollY);
      pop.style.left = left + "px";
      pop.style.top  = top + "px";
    }catch(e){
      // fallback center
      pop.style.left = "calc(50% - 90px)";
      pop.style.top  = "120px";
    }
  }

  function buildDialPopover(block, servoName, initAngle){
    const pop = document.createElement('div');
    pop.className = 'xrobo-dial-pop';
    pop.setAttribute('role','dialog');
    pop.setAttribute('aria-label','서보 다이얼');
    pop.innerHTML = [
      '<div class="xrobo-dial-head"><div>다이얼 '+servoName+'</div><div class="xrobo-dial-head-right"><button class="xrobo-live-toggle off" aria-pressed="false" title="OFF">OFF</button><button class="xrobo-dial-close" title="닫기">×</button></div></div>',
      '<div class="xrobo-dial-body">',
        '<div class="xrobo-dial-row">',
          '<div class="xrobo-dial-num"><input type="number" min="0" max="180" step="1" value="'+(initAngle||90)+'" /></div>',
          '<div class="xrobo-dial-speed"><select></select></div>',
        '</div>',
        '<svg class="xrobo-dial-svg" viewBox="0 0 100 100" aria-hidden="true">',
          '<defs>',
            '<radialGradient id="xroboDialGrad" cx="50%" cy="50%" r="50%">',
              '<stop offset="0%" stop-color="#3b82f6"/>',
              '<stop offset="100%" stop-color="#1e40af"/>',
            '</radialGradient>',
          '</defs>',
          '<circle class="xrobo-dial-ring" cx="50" cy="50" r="40"></circle>',
          '<line class="xrobo-dial-tick" x1="10" y1="50" x2="18" y2="50"></line>',
          '<line class="xrobo-dial-tick" x1="50" y1="10" x2="50" y2="18"></line>',
          '<line class="xrobo-dial-tick" x1="90" y1="50" x2="82" y2="50"></line>',
          '<circle class="xrobo-dial-dot blue" cx="50" cy="50" r="6" fill="url(#xroboDialGrad)"></circle>',
        '</svg>',
      '</div>'
    ].join('');

    // speed select 0~20
    const spdSel = pop.querySelector('select');
    for(let i=0;i<=20;i++){
      const o=document.createElement('option'); o.value=String(i); o.textContent=String(i);
      spdSel.appendChild(o);
    }
    spdSel.value = "0";
// 초기 지연시간(DELAY) 블록값을 읽어 반영 (servo_slow일 때)
(function(){
  try{
    if (block && block.type === 'servo_slow'){
      const dBlk = block.getInputTargetBlock && block.getInputTargetBlock('DELAY');
      if (dBlk && dBlk.type === 'math_number'){
        const fv = dBlk.getFieldValue && dBlk.getFieldValue('NUM');
        if (fv != null){
          const iv = parseInt(fv, 10);
          if (Number.isFinite(iv)){
            spdSel.value = String(Math.max(0, Math.min(20, iv)));
          }
        }
      }
    }
  }catch(_){}
})();


    // refs
    const inp = pop.querySelector('input');
    const svg = pop.querySelector('svg');
    const dot = pop.querySelector('.xrobo-dial-dot');
    const closeBtn = pop.querySelector('.xrobo-dial-close');
    const liveBtn = pop.querySelector('.xrobo-live-toggle');
let live = false;
function updateLiveBtn(){
  liveBtn.textContent = live ? 'ON' : 'OFF';
  liveBtn.classList.toggle('on',  live);
  liveBtn.classList.toggle('off', !live);
  liveBtn.setAttribute('aria-pressed', live ? 'true' : 'false');
  liveBtn.title = live ? 'ON' : 'OFF';
}
updateLiveBtn();
liveBtn.addEventListener('click', function(){
  live = !live;
  updateLiveBtn();
  try{
    if (typeof setRealtime === 'function') {
      setRealtime(live);
      // 멀티서보 모달이 열려 있을 때는 주기 전송 타이커도 동일하게 동기화
      if (typeof servoModal !== 'undefined' && servoModal && servoModal.classList && servoModal.classList.contains('show')) {
        try {
          if (live) { if (typeof rtStartTicker === 'function') rtStartTicker(); }
          else { if (typeof rtStopTicker === 'function') rtStopTicker(); }
        } catch(_){}
      }
    }
  }catch(_){}
});


    const state = { angle: clamp(parseInt(inp.value||'90',10)||90,0,180), speed: 0, dragging:false, lastScrDeg:90 };

    function valToScreenDeg(v){ return clamp(v,0,180); } // 0~180 그대로
    function render(){
      inp.value = String(Math.round(state.angle));
      // dot
      const R=30, a=toRad(valToScreenDeg(state.angle));
      const x=50 + R*Math.cos(a), y=50 - R*Math.sin(a);
      dot.setAttribute('cx', String(x)); dot.setAttribute('cy', String(y));
    }
    render();

    function commit(){
      try{
        if (live && typeof sendImmediate === 'function'){
          sendImmediate(`SVS ${servoName} ${state.speed} ${clamp(state.angle,0,180)}`);
        }
      }catch(_){}
    }
    const commitThrottled = throttle(commit, 100);

    // events
    inp.addEventListener('change', ()=>{
      const v = parseInt(inp.value||'0',10);
      if(Number.isFinite(v)){
        state.angle = clamp(v,0,180);
        render(); commitThrottled();
      }else{
        inp.value = String(state.angle);
      }
    });
    spdSel.addEventListener('change', ()=>{
      state.speed = clamp(parseInt(spdSel.value||'10',10)|| 0,0,20);
      commitThrottled();
    });

    function setDotActive(on){
      dot.classList.toggle('red', !!on);
      dot.classList.toggle('blue', !on);
      if(!on){ dot.setAttribute('fill', 'url(#xroboDialGrad)'); }
    }

    function pointToVal(clientX, clientY){
      const r=svg.getBoundingClientRect();
      const cx=r.left+r.width/2, cy=r.top+r.height/2;
      const dx=clientX-cx, dy=cy-clientY;
      const rad=Math.atan2(dy, dx);
      const deg=toDeg(rad); // -180..180
      const a = (deg>=0?deg:deg+360); const val = clamp(Math.round(a),0,180);
      return val;
    }
    // We'll replace the above python formatting piece for JS correctness later.

    function dialDown(ev){
      setDotActive(true);
      const p=('touches' in ev)?ev.touches[0]:ev;
      state.angle = pointToVal(p.clientX, p.clientY);
      render(); commitThrottled();
      window.addEventListener('mousemove', dialMove);
      window.addEventListener('touchmove', dialMove, {passive:false});
      window.addEventListener('mouseup', dialUp, {once:true});
      window.addEventListener('touchend', dialUp, {once:true});
      if('touches' in ev) ev.preventDefault();
    }
    function dialMove(ev){
      const p=('touches' in ev)?ev.touches[0]:ev;
      state.angle = pointToVal(p.clientX, p.clientY);
      render(); commitThrottled();
      if('touches' in ev) ev.preventDefault();
    }
    function dialUp(){
      setDotActive(false);
      window.removeEventListener('mousemove', dialMove);
      window.removeEventListener('touchmove', dialMove);
    }
    svg.addEventListener('mousedown', dialDown);
    svg.addEventListener('touchstart', dialDown, {passive:false});

    closeBtn.addEventListener('click', ()=>{ try{ applyAngleToBlock(block, state.angle); if(block && block.type==='servo_slow'){ applyDelayToBlock(block, state.speed); } }catch(_){ } document.body.removeChild(pop); document.removeEventListener('click', closer, true); });
function closer(e){ if(!pop.contains(e.target)) { try{ applyAngleToBlock(block, state.angle); if(block && block.type==='servo_slow'){ applyDelayToBlock(block, state.speed); } }catch(_){ } document.body.removeChild(pop); document.removeEventListener('click', closer, true); } }
setTimeout(()=>document.addEventListener('click', closer, true), 0);

    placeNearBlock(pop, block);
    window.addEventListener('resize', ()=>placeNearBlock(pop, block), {once:true});
    return pop;
  }

  // 외부에서 호출
  window.__xrobo_open_inline_servo_dial = function(block, outName, initAngle){
    try{
      const pop = buildDialPopover(block, outToServoName(outName), initAngle||90);
      document.body.appendChild(pop);
    }catch(e){ console.warn('inline dial 오류:', e); }
  };
})();

/* ==== [추가] USB(웹시리얼) 연결 지원: 다른 코드에 영향 최소화 ==== */
(function(){
  const enc = window._xroboEnc || new TextEncoder();  window._xroboEnc = enc;
  const dec = window._xroboDec || new TextDecoder();  window._xroboDec = dec;

  // 기존 전역(writeChar 등)을 그대로 활용하기 위해, 시리얼에서도 writeChar와 동일 인터페이스 제공
  // (이미 전역에 let writeChar 가 있다면 덮어쓰지 않음. 시리얼 연결 시에만 writeChar를 래핑)
  let _serial = { port:null, reader:null, writer:null, reading:false };
  let _transport = { type:null }; // 'ble' | 'serial'

  const $ = sel => document.querySelector(sel);
  const connectBtn = $('#connectToggle');
  const connectMenu = (function(){
    let m = document.getElementById('connectMenu');
    if(!m){ // 방어
      m = document.createElement('div');
      m.id = 'connectMenu'; m.className = 'menu';
      m.innerHTML = '<button data-mode="usb">USB</button><button data-mode="ble">블루투스</button>';
      const wrap = document.createElement('div'); wrap.className = 'dropdown'; wrap.id='connectDropdown';
      connectBtn.parentNode.insertBefore(wrap, connectBtn);
      wrap.appendChild(connectBtn); wrap.appendChild(m);
    }
    return m;
  })();

  function showConnectMenu(show){
    if(!connectMenu) return;
    connectMenu.classList.toggle('show', !!show);
    connectMenu.setAttribute('aria-hidden', show ? 'false' : 'true');
  }
  document.addEventListener('click', (e)=>{
    if(e.target.closest('#connectDropdown')) return;
    showConnectMenu(false);
  });

  // 기존 연결 버튼의 기본 클릭 로직(블루투스 토글)을 건드리지 않기 위해,
  // 캡처 단계에서 드롭다운을 우선 표시하고 기본 로직은 막는다.
  // 사용자가 메뉴에서 '블루투스'를 선택하면, 그때만 원래 로직을 1회 우회 실행한다.
  let _bypassOnce = false;
  connectBtn.addEventListener('click', async (e)=>{
    if(_bypassOnce){ _bypassOnce=false; return; }
    // 연결되어 있다면 메뉴 대신 '해제' 동작 수행
    const connected = (_transport && _transport.type) || (typeof isConnected!=='undefined' && isConnected);
    if(connected){
      e.preventDefault(); e.stopImmediatePropagation();
      try{
        if(_transport && _transport.type==='serial'){
          await usbDisconnect();
        }else{
          if(typeof disconnectBLE === 'function'){ disconnectBLE(); }
          else{
            try{ if(window.bleDevice && bleDevice.gatt) bleDevice.gatt.disconnect(); }catch(_){}
          }
          try{ setConnUI(false); }catch(_){}
        }
      }catch(_){}
      return;
    }
    // 연결 전이라면 드롭다운 메뉴 토글
    e.preventDefault(); e.stopImmediatePropagation();
    showConnectMenu(!connectMenu.classList.contains('show'));
  }, true);

  const statusDot = document.getElementById('statusDot');
  const runToggle = document.getElementById('runToggle');
  function setConnUI(on){
    if(!statusDot || !runToggle) return;
    statusDot.classList.toggle('on', !!on);
    statusDot.classList.toggle('off', !on);
    statusDot.textContent = on ? 'on' : 'off';
    runToggle.disabled = !on;
  
    try{
      var btn = document.getElementById('connectToggle');
      if(btn){
        if(on){
          btn.textContent = '해제';
          btn.classList.add('connected');
          // 연결 중에는 드롭다운 메뉴를 숨김
          var menu = document.getElementById('connectMenu');
          if(menu){ menu.classList.remove('show'); menu.setAttribute('aria-hidden','true'); }
        }else{
          btn.textContent = '연결 ▾';
          btn.classList.remove('connected');
          var menu = document.getElementById('connectMenu');
          if(menu){ menu.classList.remove('show'); menu.setAttribute('aria-hidden','true'); }
        }
      }
    }catch(_){}
}

  async function usbConnect(){
    if(!('serial' in navigator)){
      alert('이 브라우저는 Web Serial을 지원하지 않습니다. Chrome/Edge(데스크탑) 또는 Android Chrome을 사용해 주세요.');
      return;
    }
    try{
      _serial.port = await navigator.serial.requestPort();
      await _serial.port.open({ baudRate: 115200 });
      _serial.writer = _serial.port.writable.getWriter();
      _serial.reader = _serial.port.readable.getReader();
      _serial.reading = true;

      // 수신 루프: 기존 onBleChunk 파서를 그대로 사용
      (async()=>{
        try{
          while(_serial.reading){
            const { value, done } = await _serial.reader.read();
            if(done) break;
            if(value){
              // value는 Uint8Array
              const txt = dec.decode(value);
              if(typeof onBleChunk === 'function') onBleChunk(txt);
            }
          }
        }catch(err){ /* ignore */ }
        finally{
          try{ _serial.reader.releaseLock(); }catch(_){}
          _serial.reader = null;
          _serial.reading = false;
        }
      })();

      // writeChar 래핑: 기존 코드가 writeChar.writeValue(...) 를 사용하므로 동일 인터페이스 제공
      window.writeChar = {
        async writeValue(buf){
          if(!_serial.writer) throw new Error('USB writer not ready');
          if(!(buf instanceof Uint8Array)) buf = enc.encode(String(buf));
          await _serial.writer.write(buf);
        }
      };
      try{ writeChar = window.writeChar; }catch(_){ /* scope에 없으면 무시 */ }
      _transport.type = 'serial';
      setConnUI(true);
      if(typeof log === 'function') log('🔌 USB 시리얼 연결됨');
    }catch(err){
      alert('USB 연결 실패: ' + err);
      try{ if(_serial.reader){ _serial.reader.cancel(); } }catch(_){}
      try{ if(_serial.writer){ _serial.writer.releaseLock(); } }catch(_){}
      try{ if(_serial.port){ await _serial.port.close(); } }catch(_){}
      _serial = { port:null, reader:null, writer:null, reading:false };
      setConnUI(false);
    try{ if(_transport.type==='serial') writeChar=null; }catch(_){}
      }
  }

  async function usbDisconnect(){
    try{ if(_serial.reader){ _serial.reading=false; await _serial.reader.cancel(); } }catch(_){}
    try{ if(_serial.writer){ _serial.writer.releaseLock(); } }catch(_){}
    try{ if(_serial.port){ await _serial.port.close(); } }catch(_){}
    _serial = { port:null, reader:null, writer:null, reading:false };
    if(_transport.type === 'serial'){
      _transport.type = null;
      setConnUI(false);
      if(typeof log === 'function') log('🔌 USB 시리얼 연결 해제');
    }
  }

  // 메뉴 동작
  connectMenu.addEventListener('click', async (e)=>{
    const btn = e.target.closest('button[data-mode]');
    if(!btn) return;
    const mode = btn.dataset.mode;
    showConnectMenu(false);

    if(mode === 'usb'){
      // USB 연결 요청
      await usbDisconnect(); // 중복 방지
      await usbConnect();
    }else if(mode === 'ble'){
      // 기존 블루투스 토글 로직을 1회 우회 실행
      _bypassOnce = true;
      // connectBtn에 버블링 클릭 이벤트 발생시켜 기존 핸들러 실행
      connectBtn.dispatchEvent(new MouseEvent('click', {bubbles:true}));
    }
  });

  // 탭/창 닫힐 때 USB 정리
  window.addEventListener('beforeunload', ()=>{ try{ if(_serial.port) _serial.port.close(); }catch(_){} });
})();


</script>


<script id="xrobo-vsplit-script">
(function(){
  const resizer = document.getElementById('rightResizer');
  const right   = document.getElementById('right');
  if(!resizer || !right) return;

  let dragging = false;
  let startY = 0;
  let startH = 0;
  let maxH = 0;

  function getVarLogH(){
    const cs = getComputedStyle(document.documentElement);
    const v = cs.getPropertyValue('--logH').trim();
    const m = /^([\d.]+)px$/.exec(v);
    return m ? parseFloat(m[1]) : 180;
  }

  function onDown(y){
    dragging = true;
    startY = y;
    startH = getVarLogH();
    const rect = right.getBoundingClientRect();
    // 최소/최대: 로그창은 최소 80px, 최대는 패널 전체 높이 - 최소 코드창 120px - 분할바 높이
    maxH = Math.max(100, rect.height - 120 - 8);
    document.body.classList.add('vs-resizing');
  }

  function onMove(y){
    if(!dragging) return;
    let newH = startH - (y - startY);
    if (newH < 80) newH = 80;
    if (newH > maxH) newH = maxH;
    document.documentElement.style.setProperty('--logH', newH + 'px');
  }

  function onUp(){
    dragging = false;
    document.body.classList.remove('vs-resizing');
  }

  // Mouse
  resizer.addEventListener('mousedown', (e)=>{ e.preventDefault(); onDown(e.clientY); });
  window.addEventListener('mousemove', (e)=> onMove(e.clientY));
  window.addEventListener('mouseup', onUp);

  // Touch
  resizer.addEventListener('touchstart', (e)=>{ if(!e.touches||!e.touches[0]) return; onDown(e.touches[0].clientY); }, {passive:false});
  window.addEventListener('touchmove', (e)=>{ if(!e.touches||!e.touches[0]) return; onMove(e.touches[0].clientY); }, {passive:false});
  window.addEventListener('touchend', onUp);
})();
</script>


<!-- Android WebUSB fallback (non-breaking): adds WebUSB path when Web Serial is unavailable -->
<script id="xrobo-webusb-fallback">
(function(){
  'use strict';
  if(typeof window === 'undefined') return;

  // Encoders reused by existing code
  const enc = window._xroboEnc || new TextEncoder();  window._xroboEnc = enc;
  const dec = window._xroboDec || new TextDecoder();  window._xroboDec = dec;

  // Keep reference to original functions if present
  const origUsbConnect = window.usbConnect;
  const origUsbDisconnect = window.usbDisconnect;

  // Shared state with existing UI helpers
  const _transport = (window._transport) || (window._transport = { type:null });
  const setConnUI = window.setConnUI || function(){};
  const onBleChunk = window.onBleChunk || function(){};
  let writeChar = window.writeChar; // may be reassigned below

  // WebUSB state
  const wusb = {
    device: null,
    iface:  null,
    epIn:   null,
    epOut:  null,
    reading: false
  };

  function isAndroid(){ return /Android/i.test(navigator.userAgent||''); }

  async function webUsbConnect(){
    if(!('usb' in navigator)){
      throw new Error('이 브라우저는 WebUSB를 지원하지 않습니다.');
    }

    // Common USB-to-serial vendor IDs (best-effort; may vary by board)
    const filters = [
      { vendorId: 0x303A }, // Espressif
      { vendorId: 0x2341 }, // Arduino
      { vendorId: 0x10C4 }, // Silicon Labs CP210x
      { vendorId: 0x1A86 }, // WCH CH34x
      { vendorId: 0x0403 }, // FTDI
    ];

    // Request device
    const device = await navigator.usb.requestDevice({ filters });
    await device.open();

    // Select first configuration if not already selected
    if(device.configuration == null){
      await device.selectConfiguration(1);
    }

    // Find an interface that has both IN and OUT bulk endpoints
    let foundIface = null, epIn = null, epOut = null;
    for(const iface of device.configuration.interfaces){
      for(const alt of iface.alternates){
        const ein  = (alt.endpoints||[]).find(e => e.direction==='in'  && e.type==='bulk');
        const eout = (alt.endpoints||[]).find(e => e.direction==='out' && e.type==='bulk');
        if(ein && eout){
          foundIface = iface.interfaceNumber;
          epIn = ein.endpointNumber;
          epOut = eout.endpointNumber;
          break;
        }
      }
      if(foundIface!=null) break;
    }
    if(foundIface==null){
      await device.close();
      throw new Error('적절한 USB 인터페이스( bulk IN/OUT )를 찾지 못했습니다.');
    }

    await device.claimInterface(foundIface);

    // Save state
    wusb.device = device;
    wusb.iface  = foundIface;
    wusb.epIn   = epIn;
    wusb.epOut  = epOut;

    // Start read loop
    wusb.reading = true
    async function readLoop(){
      try{
        while(wusb.reading){
          const res = await device.transferIn(epIn, 64);
          if(res && res.data && res.status === 'ok'){
            const bytes = new Uint8Array(res.data.buffer);
            const txt = dec.decode(bytes);
            try{ onBleChunk(txt); }catch(_){}
          }
        }
      }catch(e){
        // stop on error
      }finally{
        wusb.reading = false;
      }
    }
    readLoop();

    // Provide same writeChar-like API used elsewhere
    window.writeChar = {
      async writeValue(buf){
        if(!(buf instanceof Uint8Array)) buf = enc.encode(String(buf));
        if(!wusb.device) throw new Error('USB 장치가 열려있지 않습니다.');
        const res = await wusb.device.transferOut(epOut, buf);
        if(res.status !== 'ok'){
          throw new Error('USB 전송 실패: ' + res.status);
        }
      }
    };
    try{ writeChar = window.writeChar; }catch(_){}

    _transport.type = 'serial'; // reuse the same path
    try{ setConnUI(true); }catch(_){}
    try{ if(typeof log === 'function') log('🔌 Android WebUSB 연결됨 (실험적)'); }catch(_){}
  }

  async function webUsbDisconnect(){
    try{ wusb.reading = false; }catch(_){}
    if(wusb.device){
      try{ await wusb.device.releaseInterface(wusb.iface); }catch(_){}
      try{ await wusb.device.close(); }catch(_){}
    }
    wusb.device=null; wusb.iface=null; wusb.epIn=null; wusb.epOut=null;
    if(_transport.type === 'serial'){
      _transport.type = null;
      try{ setConnUI(false); }catch(_){}
      try{ if(typeof log === 'function') log('🔌 Android WebUSB 연결 해제'); }catch(_){}
    }
  }

  // Replace usbConnect/usbDisconnect safely with a wrapper (non-breaking)
  if(typeof window.usbConnect === 'function'){
    window.usbConnect = async function(){
      // If Web Serial exists (desktop): use original
      if('serial' in navigator && !isAndroid()){
        return origUsbConnect();
      }
      // On Android or when Web Serial is missing: try WebUSB
      if('usb' in navigator){
        try{ await webUsbConnect(); return; }
        catch(e){
          alert('WebUSB 연결 실패: ' + e.message + '\\n지원되는 기기/펌웨어가 필요합니다.');
        }
      }
      // Fallback: show guidance
      alert('이 기기/브라우저에서는 USB 시리얼을 직접 사용할 수 없습니다. BLE 연결을 사용하거나 Android 앱을 이용해 주세요.');
    };
  }

  if(typeof window.usbDisconnect === 'function'){
    const old = origUsbDisconnect;
    window.usbDisconnect = async function(){
      // Try WebUSB disconnect first (no-op if not used)
      try{ await webUsbDisconnect(); }catch(_){}
      if(typeof old === 'function') return old();
    };
  }

})();
</script>


<!-- removed xrobo-kp4x4-v9-script -->


<!-- ▼▼▼ 추가: 데스크톱용 Blockly 숫자 입력 보정(OK→0, 취소 복원, Enter/ESC 동작) -->
<script id="xrobo-desktop-number-fix">
(function(){
  var isAndroid = /Android/i.test(navigator.userAgent||'');
  if(isAndroid || !window.Blockly) return;

  function sanitizeNumber(s){
    if(s==null) return null;
    s=String(s).trim().replace(',', '.');
    if(s==='') return null;
    var n = Number(s);
    return Number.isFinite(n) ? n : null;
  }

  // Patch FieldNumber validator: 빈값/NaN이 들어오면 기존값 유지
  try{
    var FN = Blockly.FieldNumber;
    var origValidate = FN.prototype.doClassValidation_;
    FN.prototype.doClassValidation_ = function(newValue){
      if(typeof newValue === 'string'){
        var n = sanitizeNumber(newValue);
        if(n !== null) newValue = n;
      }
      var res = origValidate ? origValidate.call(this, newValue) : newValue;
      if(res == null || (typeof res === 'number' && !Number.isFinite(res))){
        var cur = Number(this.getValue());
        return Number.isFinite(cur) ? cur : 0;
      }
      return res;
    };
  }catch(_){}

  // 숫자 입력 위젯 편집시 Enter=확인 / Esc=취소(이전값) 처리 + OK/취소 버튼 보정
  try{
    var FTI = Blockly.FieldTextInput;
    var origShow = FTI.prototype.showEditor_;
    var activeField = null;

    FTI.prototype.showEditor_ = function(opt_quietInput){
      origShow.call(this, opt_quietInput);
      var input = this.htmlInput_;
      if(!input) return;
      activeField = this;
      this.__desktopFixInitial = this.getValue();

      if(this.isNumeric_){
        input.addEventListener('keydown', (e)=>{
          if(e.key === 'Enter'){
            e.preventDefault();
            var v = sanitizeNumber(input.value);
            if(v === null) v = this.__desktopFixInitial;
            this.setValue(String(v));
            this.onFinishEditing_();
          }else if(e.key === 'Escape'){
            e.preventDefault();
            this.setValue(String(this.__desktopFixInitial));
            this.onFinishEditing_();
          }
        });
        // IME 조합 종료 후 값 확정 유도
        input.addEventListener('blur', ()=>{
          try{ input.dispatchEvent(new Event('change', {bubbles:false})); }catch(_){}
        });
      }
    };

    // OK/취소 버튼 클릭(가능한 경우) 보정: aria-label/title 탐색
    document.addEventListener('mousedown', function(ev){
      var wd = Blockly.WidgetDiv && Blockly.WidgetDiv.DIV;
      if(!wd || !wd.contains(ev.target) || !activeField || !activeField.isNumeric_) return;
      var label = (ev.target.getAttribute && (ev.target.getAttribute('aria-label')||ev.target.title)) || '';
      label = (label||'').toLowerCase();
      if(label.includes('cancel') || label.includes('취소')){
        try{ activeField.setValue(String(activeField.__desktopFixInitial)); }catch(_){}
      }else if(label.includes('ok') || label.includes('확인')){
        try{
          var inp = wd.querySelector('input, .blocklyHtmlInput');
          var v = sanitizeNumber(inp ? (inp.value||'') : '');
          if(v === null) v = activeField.__desktopFixInitial;
          activeField.setValue(String(v));
        }catch(_){}
      }
    }, true);

  }catch(_){}
})();
</script>
<!-- ▲▲▲ 데스크톱 숫자 입력 보정 끝 -->

<!-- injected: 4x4 keypad v14 (Android-only) -->
<script id="xrobo-kp4x4-v14-script">
(function(){
  // Only enable keypad on Android; on desktop Chrome, keypad is disabled.
  if(!/Android/i.test(navigator.userAgent||'')) { return; }

  'use strict';
  const isAndroid = /Android/i.test(navigator.userAgent||'');
  if(!isAndroid){ return; }
  const hasPointer = 'PointerEvent' in window;

  let pad, disp, grid;
  let activeInput = null;     // html input (if captured)
  let activeField = null;     // Blockly field instance (FieldNumber)
  let promptCallback = null;  // prompt override
  let buffer = '';
  let rafId = 0;
  let lastAnchor = {x: window.innerWidth/2, y: 140};
  let outsideBound = false;
  let committing = false;

  // press dedup (for some Androids firing twice)
  let lastPressLabel = '';
  let lastPressTime = 0;
  const PRESS_DEBOUNCE_MS = 160;

  /* ===== utils ===== */
  function safeEval(expr){
    if(typeof expr!=='string') return NaN;
    expr = expr.replace(/[^0-9+\-*/\s]/g,'').trim();
    if(!expr) return NaN;
    const tokens = expr.match(/(\d+|[+\-*/])/g) || [];
    if(tokens.length===0) return NaN;
    const values=[], ops=[]; let expectNum=true, unary=null;
    function prec(op){ return (op==='*'||op==='/')?2:1; }
    function apply(){ const op=ops.pop(), b=values.pop(), a=values.pop();
      values.push(op==='+'?a+b: op==='-'?a-b: op==='*'?a*b: (b===0?0:Math.trunc(a/b))); }
    for(const tk of tokens){
      if(/^\d+$/.test(tk)){
        let v=parseInt(tk,10); if(unary==='-') v=-v; unary=null; values.push(v); expectNum=false;
      }else{
        if(expectNum){ if(tk==='+'||tk==='-') unary=tk; }
        else{ while(ops.length && prec(ops[ops.length-1])>=prec(tk)) apply(); ops.push(tk); expectNum=true; }
      }
    }
    while(ops.length) apply();
    return values.length? values[0]:NaN;
  }
  function dispatch(el, type){ try{ el.dispatchEvent(new Event(type, {bubbles:true})); }catch(_){ } }

  /* ===== keypad UI ===== */
  function buildPad(){
    if(pad) return pad;
    pad = document.createElement('div');
    pad.id = 'xrobo-kp4x4-v14';
    pad.innerHTML = '<div class="display" aria-live="polite"></div><div class="grid" role="group" aria-label="숫자패드"></div>';
    document.body.appendChild(pad);
    disp = pad.querySelector('.display'); grid = pad.querySelector('.grid');

    const layout = [
      {t:'1'},{t:'2'},{t:'3'},{t:'←',cls:'back'},
      {t:'4'},{t:'5'},{t:'6'},{t:'C',cls:'clear'},
      {t:'7'},{t:'8'},{t:'9'},{t:'+',cls:'op'},
      {t:'*',cls:'op'},{t:'0'},{t:'/',cls:'op'},{t:'-',cls:'op'},
      // order: 확인 -> 취소
      {t:'확인',cls:'wide ok'},{t:'취소',cls:'wide cancel'}
    ];
    layout.forEach(k=>{
      const b=document.createElement('button'); b.type='button'; b.textContent=k.t;
      if(k.cls) k.cls.split(' ').forEach(c=>b.classList.add(c));
      grid.appendChild(b);
    });

    const press = (label)=>{
      const now = performance.now();
      if(label === lastPressLabel && (now - lastPressTime) < PRESS_DEBOUNCE_MS){
        return; // ignore duplicate
      }
      lastPressLabel = label; lastPressTime = now;

      if(label==='확인'){ commit(); return; }
      if(label==='취소'){ cancel(); return; }
      if(label==='C'){ buffer=''; sync(); return; }
      if(label==='←'){ buffer = buffer.slice(0, buffer.length-1); sync(); return; }
      if(/^[0-9+\-*/]$/.test(label)){ buffer += label; sync(); return; }
    };

    function getButtonFromEvent(e){
      if(e.type==='touchstart' && e.touches && e.touches[0]){
        const t=e.touches[0]; const el=document.elementFromPoint(t.clientX, t.clientY);
        return el && el.closest && el.closest('button');
      }
      return e.target && e.target.closest && e.target.closest('button');
    }

    const onPress = (e)=>{
      const btn = getButtonFromEvent(e); if(!btn) return;
      e.preventDefault(); e.stopPropagation();
      press(btn.textContent);
    };

    // Single path
    if(!grid.dataset.bound){
      if(hasPointer){
        grid.addEventListener('pointerdown', onPress, true);
      }else if('ontouchstart' in window){
        grid.addEventListener('touchstart', onPress, {passive:false, capture:true});
      }else{
        grid.addEventListener('mousedown', onPress, true);
      }
      // prevent native click duplication
      grid.addEventListener('click', function(e){ e.preventDefault(); e.stopPropagation(); }, true);
      grid.dataset.bound = '1';
    }

    // outside handler (single-binding)
    const outside = (e)=>{
      if(!pad.classList.contains('show')) return;
      if(pad.contains(e.target)) return;
      if(activeInput && e.target===activeInput) return;
      commit();
    };
    if(!outsideBound){
      if(hasPointer){
        document.addEventListener('pointerdown', outside, true);
      }else if('ontouchstart' in window){
        document.addEventListener('touchstart', outside, {passive:false, capture:true});
      }else{
        document.addEventListener('mousedown', outside, true);
      }
      outsideBound = true;
    }

    return pad;
  }

  function showPad(){ buildPad().classList.add('show'); }
  function hidePad(){ if(pad) pad.classList.remove('show'); }

  function positionNearRect(r){
    const br = pad.getBoundingClientRect();
    const pw=br.width, ph=br.height;
    const gap=8, vx=window.scrollX||0, vy=window.scrollY||0;
    let left=r.right + gap + vx, top=r.top + vy;
    if(left + pw > vx + innerWidth - 6){ left = r.left + vx - pw - gap; }
    if(top + ph > vy + innerHeight - 6){ top = Math.max(vy+6, vy + innerHeight - ph - 6); }
    if(top < vy + 6) top = vy + 6;
    pad.style.left = left + 'px'; pad.style.top = top + 'px';
  }
  function positionNearInput(input){ positionNearRect(input.getBoundingClientRect()); }
  function positionNearPoint(x,y){ positionNearRect({left:x, right:x, top:y, bottom:y, width:0, height:0}); }
  function positionNearField(field){
    try{
      const root = field && field.getClickTarget_ ? field.getClickTarget_() : (field && field.getSvgRoot && field.getSvgRoot());
      if(root && root.getBoundingClientRect){
        positionNearRect(root.getBoundingClientRect());
        return true;
      }
    }catch(_){}
    return false;
  }

  function startFollowInput(input){
    cancelAnimationFrame(rafId);
    const tick=()=>{ if(activeInput){ positionNearInput(input); rafId=requestAnimationFrame(tick);} };
    tick();
  }
  function stopFollow(){ cancelAnimationFrame(rafId); rafId=0; }

  function sync(){
    if(disp) disp.textContent = buffer;
    if(activeInput){
      activeInput.value = buffer;
      dispatch(activeInput,'input');
    }
  }

  function evaluateAndClamp(raw, inputEl){
    let num = safeEval(String(raw||'').trim());
    if(!Number.isFinite(num)) return { ok:false, val:String(raw||'') };
    const min = Number(inputEl?.getAttribute('min'));
    const max = Number(inputEl?.getAttribute('max'));
    if(Number.isFinite(min)) num = Math.max(min, num);
    if(Number.isFinite(max)) num = Math.min(max, num);
    return { ok:true, val:String(num) };
  }

  function commit(){
    if(committing) return;
    committing = true;
    try{
      if(activeField && !activeInput){
        // Field only (no html input captured): set directly
        const { ok, val } = evaluateAndClamp(buffer, null);
        try{ activeField.setValue(ok ? val : buffer); }catch(_){}
        activeField = null;
      }else if(activeField && activeInput){
        const { ok, val } = evaluateAndClamp(buffer, activeInput);
        try{ activeField.setValue(ok ? val : buffer); }catch(_){}
        activeField = null;
      }else if(typeof promptCallback === 'function'){
        const n = safeEval(buffer); const v = Number.isFinite(n) ? String(n) : buffer;
        try{ promptCallback(v); }catch(_){}
        promptCallback = null;
      }else if(activeInput){
        const { ok, val } = evaluateAndClamp(buffer, activeInput);
        activeInput.value = val;
        dispatch(activeInput,'input');
        dispatch(activeInput,'change');
      }
      try{ if(window.Blockly && Blockly.WidgetDiv && typeof Blockly.WidgetDiv.hide==='function'){ Blockly.WidgetDiv.hide(); } }catch(_){}
      activeInput = null;
      stopFollow(); hidePad();
    }finally{
      committing = false;
    }
  }

  function cancel(){
    activeField = null; promptCallback = null; activeInput = null;
    stopFollow(); hidePad();
  }

  /* ===== discover Blockly input robustly ===== */
  function findBlocklyInput(){
    try{
      if(window.Blockly){
        // 1) Preferred static ref
        if(Blockly.FieldTextInput && Blockly.FieldTextInput.htmlInput_){
          return Blockly.FieldTextInput.htmlInput_;
        }
        // 2) WidgetDiv container
        if(Blockly.WidgetDiv && Blockly.WidgetDiv.DIV){
          const el = Blockly.WidgetDiv.DIV.querySelector('input,textarea');
          if(el) return el;
        }
      }
      // 3) Document fallback
      const q = document.querySelector('.blocklyHtmlInput, .blocklyHtmlTextInput, input.blocklyHtmlInput');
      if(q) return q;
    }catch(_){}
    return null;
  }

  /* ===== openers ===== */
  function setupInputPlatform(input){
    if(isAndroid){
      input.setAttribute('readonly', 'readonly');
      input.setAttribute('inputmode','none');
      input.addEventListener('touchstart', ev=>{ ev.preventDefault(); ev.stopPropagation(); }, {capture:true, passive:false});
      setTimeout(()=>{ try{ input.blur(); }catch(_){ } }, 0);
    }else{
      input.removeAttribute('readonly');
      input.setAttribute('inputmode','numeric');
      try{ input.focus(); }catch(_){}
      input.addEventListener('keydown', function(e){
        if(e.key==='Enter'){ e.preventDefault(); commit(); }
        else if(e.key==='Escape'){ e.preventDefault(); cancel(); }
      }, {once:true, capture:true});
    }
    input.setAttribute('pattern','[0-9+\\-*/]*');
    input.setAttribute('autocomplete','off');
    input.setAttribute('autocorrect','off');
    input.setAttribute('autocapitalize','off');
    input.setAttribute('spellcheck','false');
  }

  function openForInput(input, field){
    activeInput = input; activeField = field || null; promptCallback = null;
    setupInputPlatform(input);
    buffer = String(input.value||'');
    showPad();
    positionNearInput(input);
    startFollowInput(input);
    sync();
  }

  function openForField(field){
    activeField = field || null; activeInput = null; promptCallback = null;
    buffer = (field && typeof field.getValue==='function') ? String(field.getValue()||'') : '';
    showPad();
    // position near field rect
    if(!positionNearField(field)){
      positionNearPoint(lastAnchor.x, lastAnchor.y);
    }
    sync();
  }

  function openForPrompt(defVal, anchor){
    activeInput = null; activeField = null;
    buffer = String(defVal||'');
    showPad(); positionNearPoint(anchor.x, anchor.y); sync();
  }

  /* ===== hooks ===== */
  function afterEditorOpened(field){
    // Try to capture the real input; if not found, open near field and poll briefly.
    let found = false;
    const adopt = ()=>{
      const input = findBlocklyInput();
      if(input){
        if(!pad || !pad.classList.contains('show')) showPad();
        openForInput(input, field);
        found = true;
        return true;
      }
      return false;
    };
    // attempt immediately
    if(adopt()) return;
    // fallback: show near field & poll a few times to adopt input later
    openForField(field);
    let tries = 0;
    const iv = setInterval(()=>{
      if(adopt() || ++tries > 8){ clearInterval(iv); }
    }, 50);
  }

  function patchFieldNumber(){
    try{
      if(!window.Blockly || !Blockly.FieldNumber || Blockly.FieldNumber.__xrobo_v14) return;
      function wrap(name){
        const orig = Blockly.FieldNumber.prototype[name];
        if(!orig) return false;
        Blockly.FieldNumber.prototype[name] = function(){
          const rv = orig.apply(this, arguments);
          const self = this;
          setTimeout(()=> afterEditorOpened(self), 0);
          return rv;
        };
        return true;
      }
      wrap('showEditor_') || wrap('showEditor');
      Blockly.FieldNumber.__xrobo_v14 = true;
    }catch(_){}
  }

  function patchFieldTextInput(){
    try{
      if(!window.Blockly || !Blockly.FieldTextInput || Blockly.FieldTextInput.__xrobo_v14) return;
      const proto = Blockly.FieldTextInput.prototype;
      const origShow = proto.showEditor_;
      proto.showEditor_ = function(opt_e){
        const rv = origShow ? origShow.apply(this, arguments) : undefined;
        // Only for numeric instances
        if((typeof Blockly.FieldNumber!=='undefined') && (this instanceof Blockly.FieldNumber)){
          const self = this;
          setTimeout(()=> afterEditorOpened(self), 0);
        }
        return rv;
      };
      // If some builds use prompt editor
      const origPrompt = proto.showPromptEditor_;
      if(typeof origPrompt === 'function'){
        proto.showPromptEditor_ = function(){
          if((typeof Blockly.FieldNumber!=='undefined') && (this instanceof Blockly.FieldNumber)){
            openForPrompt(this.getValue ? this.getValue() : '', lastAnchor);
            return;
          }
          return origPrompt.apply(this, arguments);
        };
      }
      Blockly.FieldTextInput.__xrobo_v14 = true;
    }catch(_){}
  }

  function patchPrompt(){
    try{
      if(!window.Blockly) return;
      const numLike = v => /^[\s]*[+\-]?\d+(?:[\s]*[+\-*/][\s]*[+\-]?\d+)*[\s]*$/.test(String(v||''));
      if(Blockly.dialog && typeof Blockly.dialog.setPrompt==='function' && !Blockly.dialog.__xrobo_v14){
        Blockly.dialog.setPrompt(function(msg, defVal, cb){
          const looksNumeric = numLike(defVal) || /value|값|number|숫자/i.test(String(msg||''));
          if(looksNumeric){
            promptCallback = v => { try{ cb(v); }catch(_){}};
            openForPrompt(defVal, lastAnchor);
          }else{
            const ans = window.prompt(String(msg||''), String(defVal||''));
            try{ cb(ans); }catch(_){}
          }
        });
        Blockly.dialog.__xrobo_v14 = true;
      }else if(!Blockly.__xrobo_prompt_v14){
        const old = Blockly.prompt;
        Blockly.prompt = function(message, defaultValue, callback){
          const looksNumeric = numLike(defaultValue) || /value|값|number|숫자/i.test(String(message||''));
          if(looksNumeric){
            promptCallback = v=>{ try{ callback(v); }catch(_){}};
            openForPrompt(defaultValue, lastAnchor);
          }else{
            return old ? old.apply(this, arguments) : window.prompt(message, defaultValue);
          }
        };
        Blockly.__xrobo_prompt_v14 = true;
      }
    }catch(_){}
  }

  // Fallback: whenever any blockly html input gains focus
  document.addEventListener('focusin', function(e){
    const t = e.target;
    if(!t) return;
    // try to identify blockly widget input
    if(t.classList && (t.classList.contains('blocklyHtmlInput') || t.classList.contains('blocklyHtmlTextInput'))){
      openForInput(t, null);
      const onBlur = ()=>{ try{ commit(); }catch(_){ cancel(); } t.removeEventListener('blur', onBlur); };
      t.addEventListener('blur', onBlur);
    } else {
      // Android 전용: 멀티서보 모달 내부 지연(speed) 입력에도 커스텀 숫자패드 연결
      try{
        const uaOk = /Android/i.test(navigator.userAgent||'');
        if(uaOk && t.matches('#servoModal .speedbox input, #boardStage .speedbox input')){
          // 기본 키보드가 뜨지 않도록 잠시 readonly 후 해제 + inputmode 힌트
          try{ t.setAttribute('inputmode','none'); t.setAttribute('autocomplete','off'); t.setAttribute('autocorrect','off'); }catch(_){}
          try{ t.setAttribute('readonly','readonly'); setTimeout(()=>{ try{ t.removeAttribute('readonly'); }catch(_){ } }, 0); }catch(_){}
          openForInput(t, null);
          const onBlur = ()=>{ try{ commit(); }catch(_){ cancel(); } t.removeEventListener('blur', onBlur); };
          t.addEventListener('blur', onBlur);
        }
      }catch(_){}
    }
  }, true);

  // Anchor point for prompt
  (function(){
  // Only enable keypad on Android; on desktop Chrome, keypad is disabled.
  if(!/Android/i.test(navigator.userAgent||'')) { return; }

    const root = document.getElementById('blocklyDiv') || document.body;
    const savePt = (e)=>{ lastAnchor = {x:e.clientX, y:e.clientY}; };
    if(hasPointer) root.addEventListener('pointerdown', savePt, true);
    else{
      root.addEventListener('mousedown', savePt, true);
      root.addEventListener('touchstart', (e)=>{ if(e.touches&&e.touches[0]) lastAnchor={x:e.touches[0].clientX, y:e.touches[0].clientY}; }, {capture:true, passive:true});
    }
  })();

  function tryPatch(){ patchFieldNumber(); patchFieldTextInput(); patchPrompt(); }
  if(document.readyState==='complete' || document.readyState==='interactive'){
    tryPatch();
  }else{
    window.addEventListener('DOMContentLoaded', tryPatch);
  }
  // Retry for late-loading builds
  let tries=0; const iv=setInterval(()=>{ tryPatch(); if(++tries>12) clearInterval(iv); }, 300);

})();
</script>
</body>
</html>
